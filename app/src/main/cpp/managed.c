// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by Embeddinator-4000.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
#include "managed.h"
#include "glib.h"
#include "mono_embeddinator.h"
#include "c-support.h"

mono_embeddinator_context_t __mono_context;
MonoImage* __managed_dll_image;

static MonoClass* class_BuiltinTypes = 0;
static MonoClass* class_ClassWithoutNamespace = 0;
static MonoClass* class_Platform = 0;
static MonoClass* class_Type_SByte = 0;
static MonoClass* class_Type_Int16 = 0;
static MonoClass* class_Type_Int32 = 0;
static MonoClass* class_Type_Int64 = 0;
static MonoClass* class_Type_Byte = 0;
static MonoClass* class_Type_UInt16 = 0;
static MonoClass* class_Type_UInt32 = 0;
static MonoClass* class_Type_UInt64 = 0;
static MonoClass* class_Type_Single = 0;
static MonoClass* class_Type_Double = 0;
static MonoClass* class_Type_Char = 0;
static MonoClass* class_Type_String = 0;
static MonoClass* class_MyException = 0;
static MonoClass* class_MyNextException = 0;
static MonoClass* class_Type_Decimal = 0;
static MonoClass* class_ExposeExtraTypes = 0;
static MonoClass* class_Arrays_Arr = 0;
static MonoClass* class_Arrays_ValueHolder = 0;
static MonoClass* class_Interfaces_IMakeItUp = 0;
static MonoClass* class_Interfaces_Supplier = 0;
static MonoClass* class_Interfaces_IOperations = 0;
static MonoClass* class_Interfaces_ManagedAdder = 0;
static MonoClass* class_Interfaces_OpConsumer = 0;
static MonoClass* class_Interfaces_ExposeIFormatProvider = 0;
static MonoClass* class_NestedClasses_ParentClass = 0;
static MonoClass* class_NestedClasses_NestedClass = 0;
static MonoClass* class_Overloads_OperatorCollision = 0;
static MonoClass* class_Overloads_AllOperators = 0;
static MonoClass* class_Overloads_AllOperatorsWithFriendly = 0;
static MonoClass* class_Overloads_EqualOverrides = 0;
static MonoClass* class_Overloads_ConflictingNamingOverload = 0;
static MonoClass* class_ShortParameters_Class = 0;
static MonoClass* class_Subscripts_BoolCollection = 0;
static MonoClass* class_Subscripts_BoolDictionaryCollection = 0;
static MonoClass* class_Subscripts_SbyteCollection = 0;
static MonoClass* class_Subscripts_SbyteDictionaryCollection = 0;
static MonoClass* class_Subscripts_ByteCollection = 0;
static MonoClass* class_Subscripts_ByteDictionaryCollection = 0;
static MonoClass* class_Subscripts_ShortCollection = 0;
static MonoClass* class_Subscripts_ShortDictionaryCollection = 0;
static MonoClass* class_Subscripts_UshortCollection = 0;
static MonoClass* class_Subscripts_UshortDictionaryCollection = 0;
static MonoClass* class_Subscripts_IntCollection = 0;
static MonoClass* class_Subscripts_IntDictionaryCollection = 0;
static MonoClass* class_Subscripts_UintCollection = 0;
static MonoClass* class_Subscripts_UintDictionaryCollection = 0;
static MonoClass* class_Subscripts_LongCollection = 0;
static MonoClass* class_Subscripts_LongDictionaryCollection = 0;
static MonoClass* class_Subscripts_UlongCollection = 0;
static MonoClass* class_Subscripts_UlongDictionaryCollection = 0;
static MonoClass* class_Subscripts_FloatCollection = 0;
static MonoClass* class_Subscripts_FloatDictionaryCollection = 0;
static MonoClass* class_Subscripts_DoubleCollection = 0;
static MonoClass* class_Subscripts_DoubleDictionaryCollection = 0;
static MonoClass* class_Subscripts_CharCollection = 0;
static MonoClass* class_Subscripts_CharDictionaryCollection = 0;
static MonoClass* class_Subscripts_StringCollection = 0;
static MonoClass* class_Subscripts_StringDictionaryCollection = 0;
static MonoClass* class_Subscripts_IntCollectionNoSetter = 0;
static MonoClass* class_Subscripts_IntCollectionNoGetter = 0;
static MonoClass* class_Structs_Point = 0;
static MonoClass* class_Properties_Query = 0;
static MonoClass* class_Properties_DuplicateIndexedProperties = 0;
static MonoClass* class_First_ClassWithSingleNamespace = 0;
static MonoClass* class_First_Second_ClassWithNestedNamespace = 0;
static MonoClass* class_First_Second_Third_ClassWithNestedNamespace = 0;
static MonoClass* class_Methods_Static = 0;
static MonoClass* class_Methods_Parameters = 0;
static MonoClass* class_Methods_Item = 0;
static MonoClass* class_Methods_Factory = 0;
static MonoClass* class_Methods_Collection = 0;
static MonoClass* class_Methods_DuplicateMethods = 0;
static MonoClass* class_Methods_SomeExtensions = 0;
static MonoClass* class_Comparable_Class = 0;
static MonoClass* class_Comparable_Generic = 0;
static MonoClass* class_Comparable_Both = 0;
static MonoClass* class_Comparable_Different = 0;
static MonoClass* class_Fields_Class = 0;
static MonoClass* class_Fields_Struct = 0;
static MonoClass* class_Exceptions_Throwers = 0;
static MonoClass* class_Exceptions_ThrowInStaticCtor = 0;
static MonoClass* class_Exceptions_Base = 0;
static MonoClass* class_Exceptions_Super = 0;
static MonoClass* class_EqualsHashOverrides_Class = 0;
static MonoClass* class_EqualsHashOverrides_EquatableClass = 0;
static MonoClass* class_EqualsHashOverrides_EquatableInt = 0;
static MonoClass* class_Enums_Enumer = 0;
static MonoClass* class_Constructors_Unique = 0;
static MonoClass* class_Constructors_SuperUnique = 0;
static MonoClass* class_Constructors_Implicit = 0;
static MonoClass* class_Constructors_AllTypeCode = 0;
static MonoClass* class_Constructors_DefaultValues = 0;
static MonoClass* class_Constructors_Duplicates = 0;

static void __initialize_mono()
{
    if (__mono_context.domain)
        return;
    mono_embeddinator_init(&__mono_context, "mono_embeddinator_binding");
}

static void __lookup_assembly_managed_dll()
{
    if (__managed_dll_image)
        return;
    __managed_dll_image = mono_embeddinator_load_assembly(&__mono_context, "managed.dll");
}

static void __lookup_class_BuiltinTypes()
{
    if (class_BuiltinTypes == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_BuiltinTypes = mono_class_from_name(__managed_dll_image, "", "BuiltinTypes");
    }
}

BuiltinTypes* BuiltinTypes_new()
{
    const char __method_name[] = "BuiltinTypes:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    BuiltinTypes* object = (BuiltinTypes*) calloc(1, sizeof(BuiltinTypes));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_BuiltinTypes);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void BuiltinTypes_ReturnsVoid(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsVoid()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

bool BuiltinTypes_ReturnsBool(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsBool()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

int8_t BuiltinTypes_ReturnsSByte(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsSByte()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int8_t*)__unbox);
}

uint8_t BuiltinTypes_ReturnsByte(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsByte()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint8_t*)__unbox);
}

int16_t BuiltinTypes_ReturnsShort(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsShort()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

uint16_t BuiltinTypes_ReturnsUShort(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsUShort()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

int32_t BuiltinTypes_ReturnsInt(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsInt()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint32_t BuiltinTypes_ReturnsUInt(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsUInt()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

int64_t BuiltinTypes_ReturnsLong(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsLong()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

uint64_t BuiltinTypes_ReturnsULong(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsULong()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

gunichar2 BuiltinTypes_ReturnsChar(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsChar()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

const char* BuiltinTypes_ReturnsString(BuiltinTypes* object)
{
    const char __method_name[] = "BuiltinTypes:ReturnsString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

bool BuiltinTypes_PassAndReturnsBool(BuiltinTypes* object, bool v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsBool(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

int8_t BuiltinTypes_PassAndReturnsSByte(BuiltinTypes* object, int8_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsSByte(sbyte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int8_t*)__unbox);
}

uint8_t BuiltinTypes_PassAndReturnsByte(BuiltinTypes* object, uint8_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsByte(byte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint8_t*)__unbox);
}

int16_t BuiltinTypes_PassAndReturnsShort(BuiltinTypes* object, int16_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsShort(int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

uint16_t BuiltinTypes_PassAndReturnsUShort(BuiltinTypes* object, uint16_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsUShort(uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

int32_t BuiltinTypes_PassAndReturnsInt(BuiltinTypes* object, int32_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsInt(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint32_t BuiltinTypes_PassAndReturnsUInt(BuiltinTypes* object, uint32_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsUInt(uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

int64_t BuiltinTypes_PassAndReturnsLong(BuiltinTypes* object, int64_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsLong(long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

uint64_t BuiltinTypes_PassAndReturnsULong(BuiltinTypes* object, uint64_t v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsULong(ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

gunichar2 BuiltinTypes_PassAndReturnsChar(BuiltinTypes* object, gunichar2 v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsChar(char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

const char* BuiltinTypes_PassAndReturnsString(BuiltinTypes* object, const char* v)
{
    const char __method_name[] = "BuiltinTypes:PassAndReturnsString(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __v_0 = (v) ? mono_string_new(__mono_context.domain, v) : 0;
    __args[0] = __v_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

void BuiltinTypes_PassOutInt(BuiltinTypes* object, int32_t* v)
{
    const char __method_name[] = "BuiltinTypes:PassOutInt(int&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void BuiltinTypes_PassRefInt(BuiltinTypes* object, int32_t* v)
{
    const char __method_name[] = "BuiltinTypes:PassRefInt(int&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = v;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void BuiltinTypes_PassOutString(BuiltinTypes* object, GString* v)
{
    const char __method_name[] = "BuiltinTypes:PassOutString(string&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __v_0 = (v->str) ? mono_string_new(__mono_context.domain, v->str) : 0;
    __args[0] = &__v_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }
    mono_embeddinator_marshal_string_to_gstring(v, __v_0);

}

void BuiltinTypes_PassRefString(BuiltinTypes* object, GString* v)
{
    const char __method_name[] = "BuiltinTypes:PassRefString(string&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_BuiltinTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_BuiltinTypes);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __v_0 = (v->str) ? mono_string_new(__mono_context.domain, v->str) : 0;
    __args[0] = &__v_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }
    mono_embeddinator_marshal_string_to_gstring(v, __v_0);

}

static void __lookup_class_ClassWithoutNamespace()
{
    if (class_ClassWithoutNamespace == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_ClassWithoutNamespace = mono_class_from_name(__managed_dll_image, "", "ClassWithoutNamespace");
    }
}

ClassWithoutNamespace* ClassWithoutNamespace_new()
{
    const char __method_name[] = "ClassWithoutNamespace:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ClassWithoutNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_ClassWithoutNamespace);
    }

    ClassWithoutNamespace* object = (ClassWithoutNamespace*) calloc(1, sizeof(ClassWithoutNamespace));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_ClassWithoutNamespace);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

const char* ClassWithoutNamespace_ToString(ClassWithoutNamespace* object)
{
    const char __method_name[] = "ClassWithoutNamespace:ToString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ClassWithoutNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_ClassWithoutNamespace);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_Platform()
{
    if (class_Platform == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Platform = mono_class_from_name(__managed_dll_image, "", "Platform");
    }
}

bool Platform_get_IsWindows()
{
    const char __method_name[] = "Platform:get_IsWindows()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Platform();
        __method = mono_embeddinator_lookup_method(__method_name, class_Platform);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

int32_t Platform_get_ExitCode()
{
    const char __method_name[] = "Platform:get_ExitCode()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Platform();
        __method = mono_embeddinator_lookup_method(__method_name, class_Platform);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void Platform_set_ExitCode(int32_t value)
{
    const char __method_name[] = "Platform:set_ExitCode(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Platform();
        __method = mono_embeddinator_lookup_method(__method_name, class_Platform);
    }


    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Type_SByte()
{
    if (class_Type_SByte == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_SByte = mono_class_from_name(__managed_dll_image, "", "Type_SByte");
    }
}

int8_t Type_SByte_get_Max()
{
    const char __method_name[] = "Type_SByte:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_SByte();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_SByte);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int8_t*)__unbox);
}

int8_t Type_SByte_get_Min()
{
    const char __method_name[] = "Type_SByte:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_SByte();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_SByte);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int8_t*)__unbox);
}

static void __lookup_class_Type_Int16()
{
    if (class_Type_Int16 == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Int16 = mono_class_from_name(__managed_dll_image, "", "Type_Int16");
    }
}

int16_t Type_Int16_get_Max()
{
    const char __method_name[] = "Type_Int16:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Int16();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Int16);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

int16_t Type_Int16_get_Min()
{
    const char __method_name[] = "Type_Int16:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Int16();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Int16);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

static void __lookup_class_Type_Int32()
{
    if (class_Type_Int32 == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Int32 = mono_class_from_name(__managed_dll_image, "", "Type_Int32");
    }
}

int32_t Type_Int32_get_Max()
{
    const char __method_name[] = "Type_Int32:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Int32();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Int32);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Type_Int32_get_Min()
{
    const char __method_name[] = "Type_Int32:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Int32();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Int32);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Type_Int64()
{
    if (class_Type_Int64 == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Int64 = mono_class_from_name(__managed_dll_image, "", "Type_Int64");
    }
}

int64_t Type_Int64_get_Max()
{
    const char __method_name[] = "Type_Int64:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Int64();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Int64);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

int64_t Type_Int64_get_Min()
{
    const char __method_name[] = "Type_Int64:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Int64();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Int64);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

static void __lookup_class_Type_Byte()
{
    if (class_Type_Byte == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Byte = mono_class_from_name(__managed_dll_image, "", "Type_Byte");
    }
}

uint8_t Type_Byte_get_Max()
{
    const char __method_name[] = "Type_Byte:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Byte();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Byte);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint8_t*)__unbox);
}

uint8_t Type_Byte_get_Min()
{
    const char __method_name[] = "Type_Byte:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Byte();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Byte);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint8_t*)__unbox);
}

static void __lookup_class_Type_UInt16()
{
    if (class_Type_UInt16 == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_UInt16 = mono_class_from_name(__managed_dll_image, "", "Type_UInt16");
    }
}

uint16_t Type_UInt16_get_Max()
{
    const char __method_name[] = "Type_UInt16:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_UInt16();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_UInt16);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

uint16_t Type_UInt16_get_Min()
{
    const char __method_name[] = "Type_UInt16:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_UInt16();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_UInt16);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

static void __lookup_class_Type_UInt32()
{
    if (class_Type_UInt32 == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_UInt32 = mono_class_from_name(__managed_dll_image, "", "Type_UInt32");
    }
}

uint32_t Type_UInt32_get_Max()
{
    const char __method_name[] = "Type_UInt32:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_UInt32();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_UInt32);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

uint32_t Type_UInt32_get_Min()
{
    const char __method_name[] = "Type_UInt32:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_UInt32();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_UInt32);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

static void __lookup_class_Type_UInt64()
{
    if (class_Type_UInt64 == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_UInt64 = mono_class_from_name(__managed_dll_image, "", "Type_UInt64");
    }
}

uint64_t Type_UInt64_get_Max()
{
    const char __method_name[] = "Type_UInt64:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_UInt64();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_UInt64);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

uint64_t Type_UInt64_get_Min()
{
    const char __method_name[] = "Type_UInt64:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_UInt64();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_UInt64);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

static void __lookup_class_Type_Single()
{
    if (class_Type_Single == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Single = mono_class_from_name(__managed_dll_image, "", "Type_Single");
    }
}

float Type_Single_get_Max()
{
    const char __method_name[] = "Type_Single:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Single();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Single);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

float Type_Single_get_Min()
{
    const char __method_name[] = "Type_Single:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Single();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Single);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

static void __lookup_class_Type_Double()
{
    if (class_Type_Double == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Double = mono_class_from_name(__managed_dll_image, "", "Type_Double");
    }
}

double Type_Double_get_Max()
{
    const char __method_name[] = "Type_Double:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Double();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Double);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((double*)__unbox);
}

double Type_Double_get_Min()
{
    const char __method_name[] = "Type_Double:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Double();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Double);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((double*)__unbox);
}

static void __lookup_class_Type_Char()
{
    if (class_Type_Char == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Char = mono_class_from_name(__managed_dll_image, "", "Type_Char");
    }
}

gunichar2 Type_Char_get_Max()
{
    const char __method_name[] = "Type_Char:get_Max()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Char();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Char);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

gunichar2 Type_Char_get_Min()
{
    const char __method_name[] = "Type_Char:get_Min()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Char();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Char);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

gunichar2 Type_Char_get_Zero()
{
    const char __method_name[] = "Type_Char:get_Zero()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_Char();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_Char);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

static void __lookup_class_Type_String()
{
    if (class_Type_String == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_String = mono_class_from_name(__managed_dll_image, "", "Type_String");
    }
}

const char* Type_String_get_NullString()
{
    const char __method_name[] = "Type_String:get_NullString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_String();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_String);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

const char* Type_String_get_EmptyString()
{
    const char __method_name[] = "Type_String:get_EmptyString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_String();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_String);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

const char* Type_String_get_NonEmptyString()
{
    const char __method_name[] = "Type_String:get_NonEmptyString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Type_String();
        __method = mono_embeddinator_lookup_method(__method_name, class_Type_String);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_MyException()
{
    if (class_MyException == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_MyException = mono_class_from_name(__managed_dll_image, "", "MyException");
    }
}

MyException* MyException_new()
{
    const char __method_name[] = "MyException:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_MyException();
        __method = mono_embeddinator_lookup_method(__method_name, class_MyException);
    }

    MyException* object = (MyException*) calloc(1, sizeof(MyException));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_MyException);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_MyNextException()
{
    if (class_MyNextException == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_MyNextException = mono_class_from_name(__managed_dll_image, "", "MyNextException");
    }
}

MyNextException* MyNextException_new()
{
    const char __method_name[] = "MyNextException:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_MyNextException();
        __method = mono_embeddinator_lookup_method(__method_name, class_MyNextException);
    }

    MyNextException* object = (MyNextException*) calloc(1, sizeof(MyNextException));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_MyNextException);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_Type_Decimal()
{
    if (class_Type_Decimal == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Type_Decimal = mono_class_from_name(__managed_dll_image, "", "Type_Decimal");
    }
}

static void __lookup_class_ExposeExtraTypes()
{
    if (class_ExposeExtraTypes == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_ExposeExtraTypes = mono_class_from_name(__managed_dll_image, "", "ExposeExtraTypes");
    }
}

ExposeExtraTypes* ExposeExtraTypes_new()
{
    const char __method_name[] = "ExposeExtraTypes:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ExposeExtraTypes();
        __method = mono_embeddinator_lookup_method(__method_name, class_ExposeExtraTypes);
    }

    ExposeExtraTypes* object = (ExposeExtraTypes*) calloc(1, sizeof(ExposeExtraTypes));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_ExposeExtraTypes);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_Arrays_Arr()
{
    if (class_Arrays_Arr == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Arrays_Arr = mono_class_from_name(__managed_dll_image, "Arrays", "Arr");
    }
}

Arrays_Arr* Arrays_Arr_new()
{
    const char __method_name[] = "Arrays.Arr:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    Arrays_Arr* object = (Arrays_Arr*) calloc(1, sizeof(Arrays_Arr));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Arrays_Arr);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

_StringArray Arrays_Arr_StringArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:StringArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _StringArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(const char*), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_string_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        MonoObject* ____result_array_element = *(MonoObject**)mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        char* __string = mono_string_to_utf8((MonoString*) ____result_array_element);
        g_array_append_val(____result_native_array.array, __string);
    }
    return ____result_native_array;
}

_BoolArray Arrays_Arr_BoolArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:BoolArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _BoolArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(bool), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_boolean_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((bool*)____result_array_element));
    }
    return ____result_native_array;
}

_CharArray Arrays_Arr_CharArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:CharArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _CharArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(gunichar2), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_char_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((gunichar2*)____result_array_element));
    }
    return ____result_native_array;
}

_DoubleArray Arrays_Arr_DoubleArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:DoubleArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _DoubleArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(double), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_double_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((double*)____result_array_element));
    }
    return ____result_native_array;
}

_FloatArray Arrays_Arr_FloatArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:FloatArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _FloatArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(float), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_single_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((float*)____result_array_element));
    }
    return ____result_native_array;
}

_SignedcharArray Arrays_Arr_SbyteArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:SbyteArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _SignedcharArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int8_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_sbyte_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int8_t*)____result_array_element));
    }
    return ____result_native_array;
}

_ShortArray Arrays_Arr_ShortArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:ShortArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _ShortArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int16_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int16_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int16_t*)____result_array_element));
    }
    return ____result_native_array;
}

_IntArray Arrays_Arr_IntArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:IntArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _IntArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int32_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int32_t*)____result_array_element));
    }
    return ____result_native_array;
}

_LongArray Arrays_Arr_LongArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:LongArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _LongArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int64_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int64_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedshortArray Arrays_Arr_UshortArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:UshortArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedshortArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint16_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_uint16_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint16_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedintArray Arrays_Arr_UintArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:UintArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedintArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint32_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_uint32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint32_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedlongArray Arrays_Arr_UlongArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:UlongArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedlongArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint64_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_uint32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint64_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedcharArray Arrays_Arr_ByteArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:ByteArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedcharArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint8_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_byte_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint8_t*)____result_array_element));
    }
    return ____result_native_array;
}

_StringArray Arrays_Arr_get_GetNull(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:get_GetNull()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _StringArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(const char*), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_string_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        MonoObject* ____result_array_element = *(MonoObject**)mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        char* __string = mono_string_to_utf8((MonoString*) ____result_array_element);
        g_array_append_val(____result_native_array.array, __string);
    }
    return ____result_native_array;
}

_StringArray Arrays_Arr_get_StringArr(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:get_StringArr()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _StringArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(const char*), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_string_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        MonoObject* ____result_array_element = *(MonoObject**)mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        char* __string = mono_string_to_utf8((MonoString*) ____result_array_element);
        g_array_append_val(____result_native_array.array, __string);
    }
    return ____result_native_array;
}

_IntArray Arrays_Arr_get_IntArr(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:get_IntArr()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _IntArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int32_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int32_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedcharArray Arrays_Arr_get_ByteArr(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:get_ByteArr()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedcharArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint8_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_byte_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint8_t*)____result_array_element));
    }
    return ____result_native_array;
}

_StringArray Arrays_Arr_StringArrMethod_1(Arrays_Arr* object, _StringArray strArr)
{
    const char __method_name[] = "Arrays.Arr:StringArrMethod(string[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __strArr_element_class = mono_class_get_element_class(mono_get_string_class());
    MonoArray* __strArr_array = mono_array_new(__mono_context.domain, __strArr_element_class, strArr.array->len);
    for (int __i = 0; __i < strArr.array->len; __i++)
    {
        const char* __strArr_array_element = g_array_index(strArr.array, const char*, __i);
        MonoString* ____strArr_array_element_0 = (__strArr_array_element) ? mono_string_new(__mono_context.domain, __strArr_array_element) : 0;
        mono_array_setref(__strArr_array, __i, ____strArr_array_element_0);
    }
    __args[0] = __strArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _StringArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(const char*), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_string_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        MonoObject* ____result_array_element = *(MonoObject**)mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        char* __string = mono_string_to_utf8((MonoString*) ____result_array_element);
        g_array_append_val(____result_native_array.array, __string);
    }
    return ____result_native_array;
}

_BoolArray Arrays_Arr_BoolArrMethod_1(Arrays_Arr* object, _BoolArray boolArr)
{
    const char __method_name[] = "Arrays.Arr:BoolArrMethod(bool[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __boolArr_element_class = mono_class_get_element_class(mono_get_boolean_class());
    MonoArray* __boolArr_array = mono_array_new(__mono_context.domain, __boolArr_element_class, boolArr.array->len);
    for (int __i = 0; __i < boolArr.array->len; __i++)
    {
        bool __boolArr_array_element = g_array_index(boolArr.array, bool, __i);
        mono_array_set(__boolArr_array, bool, __i, __boolArr_array_element);
    }
    __args[0] = __boolArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _BoolArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(bool), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_boolean_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((bool*)____result_array_element));
    }
    return ____result_native_array;
}

_CharArray Arrays_Arr_CharArrMethod_1(Arrays_Arr* object, _CharArray charArr)
{
    const char __method_name[] = "Arrays.Arr:CharArrMethod(char[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __charArr_element_class = mono_class_get_element_class(mono_get_char_class());
    MonoArray* __charArr_array = mono_array_new(__mono_context.domain, __charArr_element_class, charArr.array->len);
    for (int __i = 0; __i < charArr.array->len; __i++)
    {
        gunichar2 __charArr_array_element = g_array_index(charArr.array, gunichar2, __i);
        mono_array_set(__charArr_array, gunichar2, __i, __charArr_array_element);
    }
    __args[0] = __charArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _CharArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(gunichar2), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_char_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((gunichar2*)____result_array_element));
    }
    return ____result_native_array;
}

_SignedcharArray Arrays_Arr_SbyteArrMethod_1(Arrays_Arr* object, _SignedcharArray sbyteArr)
{
    const char __method_name[] = "Arrays.Arr:SbyteArrMethod(sbyte[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __sbyteArr_element_class = mono_class_get_element_class(mono_get_sbyte_class());
    MonoArray* __sbyteArr_array = mono_array_new(__mono_context.domain, __sbyteArr_element_class, sbyteArr.array->len);
    for (int __i = 0; __i < sbyteArr.array->len; __i++)
    {
        int8_t __sbyteArr_array_element = g_array_index(sbyteArr.array, int8_t, __i);
        mono_array_set(__sbyteArr_array, int8_t, __i, __sbyteArr_array_element);
    }
    __args[0] = __sbyteArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _SignedcharArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int8_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_sbyte_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int8_t*)____result_array_element));
    }
    return ____result_native_array;
}

_ShortArray Arrays_Arr_ShortArrMethod_1(Arrays_Arr* object, _ShortArray shortArr)
{
    const char __method_name[] = "Arrays.Arr:ShortArrMethod(int16[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __shortArr_element_class = mono_class_get_element_class(mono_get_int16_class());
    MonoArray* __shortArr_array = mono_array_new(__mono_context.domain, __shortArr_element_class, shortArr.array->len);
    for (int __i = 0; __i < shortArr.array->len; __i++)
    {
        int16_t __shortArr_array_element = g_array_index(shortArr.array, int16_t, __i);
        mono_array_set(__shortArr_array, int16_t, __i, __shortArr_array_element);
    }
    __args[0] = __shortArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _ShortArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int16_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int16_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int16_t*)____result_array_element));
    }
    return ____result_native_array;
}

_IntArray Arrays_Arr_IntArrMethod_1(Arrays_Arr* object, _IntArray intArr)
{
    const char __method_name[] = "Arrays.Arr:IntArrMethod(int[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __intArr_element_class = mono_class_get_element_class(mono_get_int32_class());
    MonoArray* __intArr_array = mono_array_new(__mono_context.domain, __intArr_element_class, intArr.array->len);
    for (int __i = 0; __i < intArr.array->len; __i++)
    {
        int32_t __intArr_array_element = g_array_index(intArr.array, int32_t, __i);
        mono_array_set(__intArr_array, int32_t, __i, __intArr_array_element);
    }
    __args[0] = __intArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _IntArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int32_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int32_t*)____result_array_element));
    }
    return ____result_native_array;
}

_LongArray Arrays_Arr_LongArrMethod_1(Arrays_Arr* object, _LongArray longArr)
{
    const char __method_name[] = "Arrays.Arr:LongArrMethod(long[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __longArr_element_class = mono_class_get_element_class(mono_get_int32_class());
    MonoArray* __longArr_array = mono_array_new(__mono_context.domain, __longArr_element_class, longArr.array->len);
    for (int __i = 0; __i < longArr.array->len; __i++)
    {
        int64_t __longArr_array_element = g_array_index(longArr.array, int64_t, __i);
        mono_array_set(__longArr_array, int64_t, __i, __longArr_array_element);
    }
    __args[0] = __longArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _LongArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int64_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int64_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedshortArray Arrays_Arr_UshortArrMethod_1(Arrays_Arr* object, _UnsignedshortArray ushortArr)
{
    const char __method_name[] = "Arrays.Arr:UshortArrMethod(uint16[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __ushortArr_element_class = mono_class_get_element_class(mono_get_uint16_class());
    MonoArray* __ushortArr_array = mono_array_new(__mono_context.domain, __ushortArr_element_class, ushortArr.array->len);
    for (int __i = 0; __i < ushortArr.array->len; __i++)
    {
        uint16_t __ushortArr_array_element = g_array_index(ushortArr.array, uint16_t, __i);
        mono_array_set(__ushortArr_array, uint16_t, __i, __ushortArr_array_element);
    }
    __args[0] = __ushortArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedshortArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint16_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_uint16_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint16_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedintArray Arrays_Arr_UintArrMethod_1(Arrays_Arr* object, _UnsignedintArray uintArr)
{
    const char __method_name[] = "Arrays.Arr:UintArrMethod(uint[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __uintArr_element_class = mono_class_get_element_class(mono_get_uint32_class());
    MonoArray* __uintArr_array = mono_array_new(__mono_context.domain, __uintArr_element_class, uintArr.array->len);
    for (int __i = 0; __i < uintArr.array->len; __i++)
    {
        uint32_t __uintArr_array_element = g_array_index(uintArr.array, uint32_t, __i);
        mono_array_set(__uintArr_array, uint32_t, __i, __uintArr_array_element);
    }
    __args[0] = __uintArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedintArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint32_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_uint32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint32_t*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedlongArray Arrays_Arr_UlongArrMethod_1(Arrays_Arr* object, _UnsignedlongArray ulongArr)
{
    const char __method_name[] = "Arrays.Arr:UlongArrMethod(ulong[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __ulongArr_element_class = mono_class_get_element_class(mono_get_uint32_class());
    MonoArray* __ulongArr_array = mono_array_new(__mono_context.domain, __ulongArr_element_class, ulongArr.array->len);
    for (int __i = 0; __i < ulongArr.array->len; __i++)
    {
        uint64_t __ulongArr_array_element = g_array_index(ulongArr.array, uint64_t, __i);
        mono_array_set(__ulongArr_array, uint64_t, __i, __ulongArr_array_element);
    }
    __args[0] = __ulongArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedlongArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint64_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_uint32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint64_t*)____result_array_element));
    }
    return ____result_native_array;
}

_FloatArray Arrays_Arr_FloatArrMethod_1(Arrays_Arr* object, _FloatArray floatArr)
{
    const char __method_name[] = "Arrays.Arr:FloatArrMethod(single[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __floatArr_element_class = mono_class_get_element_class(mono_get_single_class());
    MonoArray* __floatArr_array = mono_array_new(__mono_context.domain, __floatArr_element_class, floatArr.array->len);
    for (int __i = 0; __i < floatArr.array->len; __i++)
    {
        float __floatArr_array_element = g_array_index(floatArr.array, float, __i);
        mono_array_set(__floatArr_array, float, __i, __floatArr_array_element);
    }
    __args[0] = __floatArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _FloatArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(float), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_single_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((float*)____result_array_element));
    }
    return ____result_native_array;
}

_DoubleArray Arrays_Arr_DoubleArrMethod_1(Arrays_Arr* object, _DoubleArray doubleArr)
{
    const char __method_name[] = "Arrays.Arr:DoubleArrMethod(double[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __doubleArr_element_class = mono_class_get_element_class(mono_get_double_class());
    MonoArray* __doubleArr_array = mono_array_new(__mono_context.domain, __doubleArr_element_class, doubleArr.array->len);
    for (int __i = 0; __i < doubleArr.array->len; __i++)
    {
        double __doubleArr_array_element = g_array_index(doubleArr.array, double, __i);
        mono_array_set(__doubleArr_array, double, __i, __doubleArr_array_element);
    }
    __args[0] = __doubleArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _DoubleArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(double), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_double_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((double*)____result_array_element));
    }
    return ____result_native_array;
}

_UnsignedcharArray Arrays_Arr_ByteArrMethod_1(Arrays_Arr* object, _UnsignedcharArray byteArr)
{
    const char __method_name[] = "Arrays.Arr:ByteArrMethod(byte[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoClass* __byteArr_element_class = mono_class_get_element_class(mono_get_byte_class());
    MonoArray* __byteArr_array = mono_array_new(__mono_context.domain, __byteArr_element_class, byteArr.array->len);
    for (int __i = 0; __i < byteArr.array->len; __i++)
    {
        uint8_t __byteArr_array_element = g_array_index(byteArr.array, uint8_t, __i);
        mono_array_set(__byteArr_array, uint8_t, __i, __byteArr_array_element);
    }
    __args[0] = __byteArr_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _UnsignedcharArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(uint8_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_byte_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((uint8_t*)____result_array_element));
    }
    return ____result_native_array;
}

_StringArray Arrays_Arr_GetNullMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:GetNullMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _StringArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(const char*), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_string_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        MonoObject* ____result_array_element = *(MonoObject**)mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        char* __string = mono_string_to_utf8((MonoString*) ____result_array_element);
        g_array_append_val(____result_native_array.array, __string);
    }
    return ____result_native_array;
}

_StringArray Arrays_Arr_StringNullArrMethod(Arrays_Arr* object)
{
    const char __method_name[] = "Arrays.Arr:StringNullArrMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _StringArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(const char*), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_string_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        MonoObject* ____result_array_element = *(MonoObject**)mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        char* __string = mono_string_to_utf8((MonoString*) ____result_array_element);
        g_array_append_val(____result_native_array.array, __string);
    }
    return ____result_native_array;
}

void Arrays_Arr_StringArrRef(Arrays_Arr* object, GString*** strArr)
{
    const char __method_name[] = "Arrays.Arr:StringArrRef(string[]&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Arrays_Arr_LongArrRef(Arrays_Arr* object, int64_t** longArr)
{
    const char __method_name[] = "Arrays.Arr:LongArrRef(long[]&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Arrays_Arr_ByteArrRef(Arrays_Arr* object, uint8_t** byteArr)
{
    const char __method_name[] = "Arrays.Arr:ByteArrRef(byte[]&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Arrays_Arr_SumByteArray(_UnsignedcharArray array)
{
    const char __method_name[] = "Arrays.Arr:SumByteArray(byte[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }


    void* __args[1];
    MonoClass* __array_element_class = mono_class_get_element_class(mono_get_byte_class());
    MonoArray* __array_array = mono_array_new(__mono_context.domain, __array_element_class, array.array->len);
    for (int __i = 0; __i < array.array->len; __i++)
    {
        uint8_t __array_array_element = g_array_index(array.array, uint8_t, __i);
        mono_array_set(__array_array, uint8_t, __i, __array_array_element);
    }
    __args[0] = __array_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

_IntArray Arrays_Arr_ReturnsIntArray()
{
    const char __method_name[] = "Arrays.Arr:ReturnsIntArray()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _IntArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(int32_t), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_int32_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        char* ____result_array_element = mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        g_array_append_val(____result_native_array.array, *((int32_t*)____result_array_element));
    }
    return ____result_native_array;
}

_StringArray Arrays_Arr_ReturnsStringArray()
{
    const char __method_name[] = "Arrays.Arr:ReturnsStringArray()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_Arr();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_Arr);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    MonoArray* ____result_array = (MonoArray*) __result;
    uintptr_t ____result_array_size = mono_array_length(____result_array);
    _StringArray ____result_native_array;
    ____result_native_array.array = g_array_sized_new(/*zero_terminated=*/FALSE, /*clear_=*/TRUE, sizeof(const char*), ____result_array_size);
    MonoClass* ____result_element_class = mono_class_get_element_class(mono_get_string_class());
    gint32 ____result_array_element_size = mono_class_array_element_size(____result_element_class);
    for (int __i = 0; __i < ____result_array_size; __i++)
    {
        MonoObject* ____result_array_element = *(MonoObject**)mono_array_addr_with_size(____result_array, ____result_array_element_size, __i);
        char* __string = mono_string_to_utf8((MonoString*) ____result_array_element);
        g_array_append_val(____result_native_array.array, __string);
    }
    return ____result_native_array;
}

static void __lookup_class_Arrays_ValueHolder()
{
    if (class_Arrays_ValueHolder == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Arrays_ValueHolder = mono_class_from_name(__managed_dll_image, "Arrays", "ValueHolder");
    }
}

Arrays_ValueHolder* Arrays_ValueHolder_new(int32_t intValue)
{
    const char __method_name[] = "Arrays.ValueHolder:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_ValueHolder();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_ValueHolder);
    }

    Arrays_ValueHolder* object = (Arrays_ValueHolder*) calloc(1, sizeof(Arrays_ValueHolder));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Arrays_ValueHolder);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &intValue;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Arrays_ValueHolder_get_IntValue(Arrays_ValueHolder* object)
{
    const char __method_name[] = "Arrays.ValueHolder:get_IntValue()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Arrays_ValueHolder();
        __method = mono_embeddinator_lookup_method(__method_name, class_Arrays_ValueHolder);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Interfaces_IMakeItUp()
{
    if (class_Interfaces_IMakeItUp == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Interfaces_IMakeItUp = mono_class_from_name(__managed_dll_image, "Interfaces", "IMakeItUp");
    }
}

bool Interfaces_IMakeItUp_get_Boolean(Interfaces_IMakeItUp* object)
{
    const char __method_name[] = "Interfaces.IMakeItUp:get_Boolean()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_IMakeItUp();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_IMakeItUp);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

const char* Interfaces_IMakeItUp_Convert(Interfaces_IMakeItUp* object, int32_t integer)
{
    const char __method_name[] = "Interfaces.IMakeItUp:Convert(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_IMakeItUp();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_IMakeItUp);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &integer;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

const char* Interfaces_IMakeItUp_Convert_1(Interfaces_IMakeItUp* object, int64_t longint)
{
    const char __method_name[] = "Interfaces.IMakeItUp:Convert(long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_IMakeItUp();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_IMakeItUp);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &longint;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_Interfaces_Supplier()
{
    if (class_Interfaces_Supplier == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Interfaces_Supplier = mono_class_from_name(__managed_dll_image, "Interfaces", "Supplier");
    }
}

Interfaces_IMakeItUp* Interfaces_Supplier_Create()
{
    const char __method_name[] = "Interfaces.Supplier:Create()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_Supplier();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_Supplier);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Interfaces_IMakeItUp* __result_obj = __result ? (Interfaces_IMakeItUp*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

static void __lookup_class_Interfaces_IOperations()
{
    if (class_Interfaces_IOperations == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Interfaces_IOperations = mono_class_from_name(__managed_dll_image, "Interfaces", "IOperations");
    }
}

int32_t Interfaces_IOperations_AddInt(Interfaces_IOperations* object, int32_t a, int32_t b)
{
    const char __method_name[] = "Interfaces.IOperations:AddInt(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_IOperations();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_IOperations);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &a;
    __args[1] = &b;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Interfaces_ManagedAdder()
{
    if (class_Interfaces_ManagedAdder == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Interfaces_ManagedAdder = mono_class_from_name(__managed_dll_image, "Interfaces", "ManagedAdder");
    }
}

Interfaces_ManagedAdder* Interfaces_ManagedAdder_new()
{
    const char __method_name[] = "Interfaces.ManagedAdder:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_ManagedAdder();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_ManagedAdder);
    }

    Interfaces_ManagedAdder* object = (Interfaces_ManagedAdder*) calloc(1, sizeof(Interfaces_ManagedAdder));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Interfaces_ManagedAdder);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Interfaces_ManagedAdder_AddInt(Interfaces_ManagedAdder* object, int32_t a, int32_t b)
{
    const char __method_name[] = "Interfaces.ManagedAdder:AddInt(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_ManagedAdder();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_ManagedAdder);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &a;
    __args[1] = &b;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Interfaces_OpConsumer()
{
    if (class_Interfaces_OpConsumer == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Interfaces_OpConsumer = mono_class_from_name(__managed_dll_image, "Interfaces", "OpConsumer");
    }
}

Interfaces_OpConsumer* Interfaces_OpConsumer_new()
{
    const char __method_name[] = "Interfaces.OpConsumer:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_OpConsumer();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_OpConsumer);
    }

    Interfaces_OpConsumer* object = (Interfaces_OpConsumer*) calloc(1, sizeof(Interfaces_OpConsumer));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Interfaces_OpConsumer);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Interfaces_OpConsumer_DoAddition(Interfaces_IOperations* ops, int32_t a, int32_t b)
{
    const char __method_name[] = "Interfaces.OpConsumer:DoAddition(Interfaces.IOperations,int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_OpConsumer();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_OpConsumer);
    }


    void* __args[3];
    __args[0] = ops ? mono_gchandle_get_target(ops->_handle) : 0;
    __args[1] = &a;
    __args[2] = &b;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool Interfaces_OpConsumer_TestManagedAdder(int32_t a, int32_t b)
{
    const char __method_name[] = "Interfaces.OpConsumer:TestManagedAdder(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_OpConsumer();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_OpConsumer);
    }


    void* __args[2];
    __args[0] = &a;
    __args[1] = &b;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Interfaces_ExposeIFormatProvider()
{
    if (class_Interfaces_ExposeIFormatProvider == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Interfaces_ExposeIFormatProvider = mono_class_from_name(__managed_dll_image, "Interfaces", "ExposeIFormatProvider");
    }
}

Interfaces_ExposeIFormatProvider* Interfaces_ExposeIFormatProvider_new()
{
    const char __method_name[] = "Interfaces.ExposeIFormatProvider:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Interfaces_ExposeIFormatProvider();
        __method = mono_embeddinator_lookup_method(__method_name, class_Interfaces_ExposeIFormatProvider);
    }

    Interfaces_ExposeIFormatProvider* object = (Interfaces_ExposeIFormatProvider*) calloc(1, sizeof(Interfaces_ExposeIFormatProvider));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Interfaces_ExposeIFormatProvider);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_NestedClasses_ParentClass()
{
    if (class_NestedClasses_ParentClass == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_NestedClasses_ParentClass = mono_class_from_name(__managed_dll_image, "NestedClasses", "ParentClass");
    }
}

NestedClasses_ParentClass* NestedClasses_ParentClass_new()
{
    const char __method_name[] = "NestedClasses.ParentClass:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_NestedClasses_ParentClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_NestedClasses_ParentClass);
    }

    NestedClasses_ParentClass* object = (NestedClasses_ParentClass*) calloc(1, sizeof(NestedClasses_ParentClass));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_NestedClasses_ParentClass);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

NestedClasses_NestedClass* NestedClasses_ParentClass_get_Nested(NestedClasses_ParentClass* object)
{
    const char __method_name[] = "NestedClasses.ParentClass:get_Nested()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_NestedClasses_ParentClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_NestedClasses_ParentClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    NestedClasses_NestedClass* __result_obj = __result ? (NestedClasses_NestedClass*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void NestedClasses_ParentClass_set_Nested(NestedClasses_ParentClass* object, NestedClasses_NestedClass* value)
{
    const char __method_name[] = "NestedClasses.ParentClass:set_Nested(NestedClasses.ParentClass+NestedClass)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_NestedClasses_ParentClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_NestedClasses_ParentClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = value ? mono_gchandle_get_target(value->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t NestedClasses_ParentClass_AddNumbers(NestedClasses_ParentClass* object, int32_t x, int32_t y)
{
    const char __method_name[] = "NestedClasses.ParentClass:AddNumbers(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_NestedClasses_ParentClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_NestedClasses_ParentClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &x;
    __args[1] = &y;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t NestedClasses_ParentClass_get_Sum(NestedClasses_ParentClass* object)
{
    const char __method_name[] = "NestedClasses.ParentClass:get_Sum()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_NestedClasses_ParentClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_NestedClasses_ParentClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_NestedClasses_NestedClass()
{
    if (class_NestedClasses_NestedClass == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_NestedClasses_NestedClass = mono_class_from_name(__managed_dll_image, "NestedClasses", "NestedClass");
    }
}

NestedClasses_NestedClass* NestedClasses_NestedClass_new()
{
    const char __method_name[] = "NestedClasses.ParentClass+NestedClass:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_NestedClasses_NestedClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_NestedClasses_NestedClass);
    }

    NestedClasses_NestedClass* object = (NestedClasses_NestedClass*) calloc(1, sizeof(NestedClasses_NestedClass));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_NestedClasses_NestedClass);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t NestedClasses_NestedClass_Addition(NestedClasses_NestedClass* object, int32_t x, int32_t y)
{
    const char __method_name[] = "NestedClasses.ParentClass+NestedClass:Addition(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_NestedClasses_NestedClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_NestedClasses_NestedClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &x;
    __args[1] = &y;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t NestedClasses_NestedClass_get_X(NestedClasses_NestedClass* object)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_NestedClasses_NestedClass();
        const char __field_name[] = "X";
        __field = mono_class_get_field_from_name(class_NestedClasses_NestedClass, __field_name);
    }
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, __instance);
    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void NestedClasses_NestedClass_set_X(NestedClasses_NestedClass* object, int32_t value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_NestedClasses_NestedClass();
        const char __field_name[] = "X";
        __field = mono_class_get_field_from_name(class_NestedClasses_NestedClass, __field_name);
    }
    void* __value = &value;
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    mono_field_set_value(__instance, __field, __value);
}

int32_t NestedClasses_NestedClass_get_Y(NestedClasses_NestedClass* object)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_NestedClasses_NestedClass();
        const char __field_name[] = "Y";
        __field = mono_class_get_field_from_name(class_NestedClasses_NestedClass, __field_name);
    }
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, __instance);
    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void NestedClasses_NestedClass_set_Y(NestedClasses_NestedClass* object, int32_t value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_NestedClasses_NestedClass();
        const char __field_name[] = "Y";
        __field = mono_class_get_field_from_name(class_NestedClasses_NestedClass, __field_name);
    }
    void* __value = &value;
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    mono_field_set_value(__instance, __field, __value);
}

int32_t NestedClasses_NestedClass_get_Sum(NestedClasses_NestedClass* object)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_NestedClasses_NestedClass();
        const char __field_name[] = "Sum";
        __field = mono_class_get_field_from_name(class_NestedClasses_NestedClass, __field_name);
    }
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, __instance);
    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void NestedClasses_NestedClass_set_Sum(NestedClasses_NestedClass* object, int32_t value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_NestedClasses_NestedClass();
        const char __field_name[] = "Sum";
        __field = mono_class_get_field_from_name(class_NestedClasses_NestedClass, __field_name);
    }
    void* __value = &value;
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    mono_field_set_value(__instance, __field, __value);
}

static void __lookup_class_Overloads_OperatorCollision()
{
    if (class_Overloads_OperatorCollision == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Overloads_OperatorCollision = mono_class_from_name(__managed_dll_image, "Overloads", "OperatorCollision");
    }
}

Overloads_OperatorCollision* Overloads_OperatorCollision_new(int32_t val)
{
    const char __method_name[] = "Overloads.OperatorCollision:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_OperatorCollision();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_OperatorCollision);
    }

    Overloads_OperatorCollision* object = (Overloads_OperatorCollision*) calloc(1, sizeof(Overloads_OperatorCollision));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Overloads_OperatorCollision);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &val;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Overloads_OperatorCollision_get_Value(Overloads_OperatorCollision* object)
{
    const char __method_name[] = "Overloads.OperatorCollision:get_Value()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_OperatorCollision();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_OperatorCollision);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

Overloads_OperatorCollision* Overloads_OperatorCollision_op_Addition(Overloads_OperatorCollision* c1, Overloads_OperatorCollision* c2)
{
    const char __method_name[] = "Overloads.OperatorCollision:op_Addition(Overloads.OperatorCollision,Overloads.OperatorCollision)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_OperatorCollision();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_OperatorCollision);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_OperatorCollision* __result_obj = __result ? (Overloads_OperatorCollision*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_OperatorCollision* Overloads_OperatorCollision_Add(Overloads_OperatorCollision* c1, Overloads_OperatorCollision* c2)
{
    const char __method_name[] = "Overloads.OperatorCollision:Add(Overloads.OperatorCollision,Overloads.OperatorCollision)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_OperatorCollision();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_OperatorCollision);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_OperatorCollision* __result_obj = __result ? (Overloads_OperatorCollision*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_OperatorCollision* Overloads_OperatorCollision_op_Subtraction(Overloads_OperatorCollision* c1, Overloads_OperatorCollision* c2)
{
    const char __method_name[] = "Overloads.OperatorCollision:op_Subtraction(Overloads.OperatorCollision,Overloads.OperatorCollision)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_OperatorCollision();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_OperatorCollision);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_OperatorCollision* __result_obj = __result ? (Overloads_OperatorCollision*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_OperatorCollision* Overloads_OperatorCollision_Multiply(Overloads_OperatorCollision* c1, Overloads_OperatorCollision* c2)
{
    const char __method_name[] = "Overloads.OperatorCollision:Multiply(Overloads.OperatorCollision,Overloads.OperatorCollision)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_OperatorCollision();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_OperatorCollision);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_OperatorCollision* __result_obj = __result ? (Overloads_OperatorCollision*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

static void __lookup_class_Overloads_AllOperators()
{
    if (class_Overloads_AllOperators == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Overloads_AllOperators = mono_class_from_name(__managed_dll_image, "Overloads", "AllOperators");
    }
}

Overloads_AllOperators* Overloads_AllOperators_new(int32_t val)
{
    const char __method_name[] = "Overloads.AllOperators:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }

    Overloads_AllOperators* object = (Overloads_AllOperators*) calloc(1, sizeof(Overloads_AllOperators));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Overloads_AllOperators);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &val;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Overloads_AllOperators_get_Value(Overloads_AllOperators* object)
{
    const char __method_name[] = "Overloads.AllOperators:get_Value()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

Overloads_AllOperators* Overloads_AllOperators_op_Addition(Overloads_AllOperators* c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_Addition(Overloads.AllOperators,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Subtraction(Overloads_AllOperators* c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_Subtraction(Overloads.AllOperators,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Multiply(Overloads_AllOperators* c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_Multiply(Overloads.AllOperators,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Division(Overloads_AllOperators* c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_Division(Overloads.AllOperators,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Division_1(Overloads_AllOperators* c1, int32_t c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_Division(Overloads.AllOperators,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &c2;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Division_2(int32_t c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_Division(int,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = &c1;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Division_3(Overloads_AllOperators* c1, int64_t c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_Division(Overloads.AllOperators,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &c2;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_ExclusiveOr(Overloads_AllOperators* c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_ExclusiveOr(Overloads.AllOperators,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_BitwiseOr(Overloads_AllOperators* c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_BitwiseOr(Overloads.AllOperators,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_BitwiseAnd(Overloads_AllOperators* c1, Overloads_AllOperators* c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_BitwiseAnd(Overloads.AllOperators,Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_BitwiseAnd_1(Overloads_AllOperators* c1, int32_t c2)
{
    const char __method_name[] = "Overloads.AllOperators:op_BitwiseAnd(Overloads.AllOperators,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &c2;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Increment(Overloads_AllOperators* c1)
{
    const char __method_name[] = "Overloads.AllOperators:op_Increment(Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_Decrement(Overloads_AllOperators* c1)
{
    const char __method_name[] = "Overloads.AllOperators:op_Decrement(Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_RightShift(Overloads_AllOperators* c1, int32_t a)
{
    const char __method_name[] = "Overloads.AllOperators:op_RightShift(Overloads.AllOperators,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &a;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_LeftShift(Overloads_AllOperators* c1, int32_t a)
{
    const char __method_name[] = "Overloads.AllOperators:op_LeftShift(Overloads.AllOperators,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &a;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_OnesComplement(Overloads_AllOperators* c1)
{
    const char __method_name[] = "Overloads.AllOperators:op_OnesComplement(Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_UnaryPlus(Overloads_AllOperators* c1)
{
    const char __method_name[] = "Overloads.AllOperators:op_UnaryPlus(Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperators* Overloads_AllOperators_op_UnaryNegation(Overloads_AllOperators* c1)
{
    const char __method_name[] = "Overloads.AllOperators:op_UnaryNegation(Overloads.AllOperators)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperators();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperators);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperators* __result_obj = __result ? (Overloads_AllOperators*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

static void __lookup_class_Overloads_AllOperatorsWithFriendly()
{
    if (class_Overloads_AllOperatorsWithFriendly == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Overloads_AllOperatorsWithFriendly = mono_class_from_name(__managed_dll_image, "Overloads", "AllOperatorsWithFriendly");
    }
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_new(int32_t val)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }

    Overloads_AllOperatorsWithFriendly* object = (Overloads_AllOperatorsWithFriendly*) calloc(1, sizeof(Overloads_AllOperatorsWithFriendly));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Overloads_AllOperatorsWithFriendly);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &val;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Overloads_AllOperatorsWithFriendly_get_Value(Overloads_AllOperatorsWithFriendly* object)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:get_Value()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_Addition(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_Addition(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Add(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Add(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_Subtraction(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_Subtraction(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Subtract(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Subtract(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_Multiply(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_Multiply(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Multiply(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Multiply(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_Division(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_Division(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Divide(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Divide(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_ExclusiveOr(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_ExclusiveOr(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Xor(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Xor(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_BitwiseOr(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_BitwiseOr(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_BitwiseOr(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:BitwiseOr(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_BitwiseAnd(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_BitwiseAnd(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_BitwiseAnd(Overloads_AllOperatorsWithFriendly* c1, Overloads_AllOperatorsWithFriendly* c2)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:BitwiseAnd(Overloads.AllOperatorsWithFriendly,Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = c2 ? mono_gchandle_get_target(c2->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_Increment(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_Increment(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Increment(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Increment(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_Decrement(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_Decrement(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Decrement(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Decrement(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_RightShift(Overloads_AllOperatorsWithFriendly* c1, int32_t a)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_RightShift(Overloads.AllOperatorsWithFriendly,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &a;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_RightShift(Overloads_AllOperatorsWithFriendly* c1, int32_t a)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:RightShift(Overloads.AllOperatorsWithFriendly,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &a;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_LeftShift(Overloads_AllOperatorsWithFriendly* c1, int32_t a)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_LeftShift(Overloads.AllOperatorsWithFriendly,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &a;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_LeftShift(Overloads_AllOperatorsWithFriendly* c1, int32_t a)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:LeftShift(Overloads.AllOperatorsWithFriendly,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[2];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    __args[1] = &a;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_OnesComplement(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_OnesComplement(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_OnesComplement(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:OnesComplement(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_UnaryPlus(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_UnaryPlus(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Plus(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Plus(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_Negate(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:Negate(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Overloads_AllOperatorsWithFriendly* Overloads_AllOperatorsWithFriendly_op_UnaryNegation(Overloads_AllOperatorsWithFriendly* c1)
{
    const char __method_name[] = "Overloads.AllOperatorsWithFriendly:op_UnaryNegation(Overloads.AllOperatorsWithFriendly)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_AllOperatorsWithFriendly();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_AllOperatorsWithFriendly);
    }


    void* __args[1];
    __args[0] = c1 ? mono_gchandle_get_target(c1->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Overloads_AllOperatorsWithFriendly* __result_obj = __result ? (Overloads_AllOperatorsWithFriendly*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

static void __lookup_class_Overloads_EqualOverrides()
{
    if (class_Overloads_EqualOverrides == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Overloads_EqualOverrides = mono_class_from_name(__managed_dll_image, "Overloads", "EqualOverrides");
    }
}

Overloads_EqualOverrides* Overloads_EqualOverrides_new(int32_t val)
{
    const char __method_name[] = "Overloads.EqualOverrides:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_EqualOverrides();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_EqualOverrides);
    }

    Overloads_EqualOverrides* object = (Overloads_EqualOverrides*) calloc(1, sizeof(Overloads_EqualOverrides));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Overloads_EqualOverrides);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &val;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Overloads_EqualOverrides_get_Value(Overloads_EqualOverrides* object)
{
    const char __method_name[] = "Overloads.EqualOverrides:get_Value()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_EqualOverrides();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_EqualOverrides);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool Overloads_EqualOverrides_op_Equality(Overloads_EqualOverrides* a, Overloads_EqualOverrides* b)
{
    const char __method_name[] = "Overloads.EqualOverrides:op_Equality(Overloads.EqualOverrides,Overloads.EqualOverrides)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_EqualOverrides();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_EqualOverrides);
    }


    void* __args[2];
    __args[0] = a ? mono_gchandle_get_target(a->_handle) : 0;
    __args[1] = b ? mono_gchandle_get_target(b->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

bool Overloads_EqualOverrides_op_Inequality(Overloads_EqualOverrides* a, Overloads_EqualOverrides* b)
{
    const char __method_name[] = "Overloads.EqualOverrides:op_Inequality(Overloads.EqualOverrides,Overloads.EqualOverrides)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_EqualOverrides();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_EqualOverrides);
    }


    void* __args[2];
    __args[0] = a ? mono_gchandle_get_target(a->_handle) : 0;
    __args[1] = b ? mono_gchandle_get_target(b->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Overloads_ConflictingNamingOverload()
{
    if (class_Overloads_ConflictingNamingOverload == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Overloads_ConflictingNamingOverload = mono_class_from_name(__managed_dll_image, "Overloads", "ConflictingNamingOverload");
    }
}

Overloads_ConflictingNamingOverload* Overloads_ConflictingNamingOverload_new()
{
    const char __method_name[] = "Overloads.ConflictingNamingOverload:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_ConflictingNamingOverload();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_ConflictingNamingOverload);
    }

    Overloads_ConflictingNamingOverload* object = (Overloads_ConflictingNamingOverload*) calloc(1, sizeof(Overloads_ConflictingNamingOverload));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Overloads_ConflictingNamingOverload);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

const char* Overloads_ConflictingNamingOverload_Format(_StringArray values)
{
    const char __method_name[] = "Overloads.ConflictingNamingOverload:Format(string[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_ConflictingNamingOverload();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_ConflictingNamingOverload);
    }


    void* __args[1];
    MonoClass* __values_element_class = mono_class_get_element_class(mono_get_string_class());
    MonoArray* __values_array = mono_array_new(__mono_context.domain, __values_element_class, values.array->len);
    for (int __i = 0; __i < values.array->len; __i++)
    {
        const char* __values_array_element = g_array_index(values.array, const char*, __i);
        MonoString* ____values_array_element_0 = (__values_array_element) ? mono_string_new(__mono_context.domain, __values_array_element) : 0;
        mono_array_setref(__values_array, __i, ____values_array_element_0);
    }
    __args[0] = __values_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

const char* Overloads_ConflictingNamingOverload_Format_1(_IntArray values)
{
    const char __method_name[] = "Overloads.ConflictingNamingOverload:Format(int[])";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Overloads_ConflictingNamingOverload();
        __method = mono_embeddinator_lookup_method(__method_name, class_Overloads_ConflictingNamingOverload);
    }


    void* __args[1];
    MonoClass* __values_element_class = mono_class_get_element_class(mono_get_int32_class());
    MonoArray* __values_array = mono_array_new(__mono_context.domain, __values_element_class, values.array->len);
    for (int __i = 0; __i < values.array->len; __i++)
    {
        int32_t __values_array_element = g_array_index(values.array, int32_t, __i);
        mono_array_set(__values_array, int32_t, __i, __values_array_element);
    }
    __args[0] = __values_array;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_ShortParameters_Class()
{
    if (class_ShortParameters_Class == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_ShortParameters_Class = mono_class_from_name(__managed_dll_image, "ShortParameters", "Class");
    }
}

ShortParameters_Class* ShortParameters_Class_new()
{
    const char __method_name[] = "ShortParameters.Class:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    ShortParameters_Class* object = (ShortParameters_Class*) calloc(1, sizeof(ShortParameters_Class));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_ShortParameters_Class);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t ShortParameters_Class_get_X(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_X()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void ShortParameters_Class_set_X(ShortParameters_Class* object, int32_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_X(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t ShortParameters_Class_get_Y(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_Y()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void ShortParameters_Class_set_Y(ShortParameters_Class* object, int32_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_Y(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

const char* ShortParameters_Class_get_A(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_A()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

void ShortParameters_Class_set_A(ShortParameters_Class* object, const char* value)
{
    const char __method_name[] = "ShortParameters.Class:set_A(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __value_0 = (value) ? mono_string_new(__mono_context.domain, value) : 0;
    __args[0] = __value_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

const char* ShortParameters_Class_get_B(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_B()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

void ShortParameters_Class_set_B(ShortParameters_Class* object, const char* value)
{
    const char __method_name[] = "ShortParameters.Class:set_B(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __value_0 = (value) ? mono_string_new(__mono_context.domain, value) : 0;
    __args[0] = __value_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

double ShortParameters_Class_get_C(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_C()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((double*)__unbox);
}

void ShortParameters_Class_set_C(ShortParameters_Class* object, double value)
{
    const char __method_name[] = "ShortParameters.Class:set_C(double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

double ShortParameters_Class_get_D(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_D()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((double*)__unbox);
}

void ShortParameters_Class_set_D(ShortParameters_Class* object, double value)
{
    const char __method_name[] = "ShortParameters.Class:set_D(double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

float ShortParameters_Class_get_E(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_E()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

void ShortParameters_Class_set_E(ShortParameters_Class* object, float value)
{
    const char __method_name[] = "ShortParameters.Class:set_E(single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

float ShortParameters_Class_get_F(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_F()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

void ShortParameters_Class_set_F(ShortParameters_Class* object, float value)
{
    const char __method_name[] = "ShortParameters.Class:set_F(single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

uint32_t ShortParameters_Class_get_G(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_G()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

void ShortParameters_Class_set_G(ShortParameters_Class* object, uint32_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_G(uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

uint32_t ShortParameters_Class_get_H(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_H()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

void ShortParameters_Class_set_H(ShortParameters_Class* object, uint32_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_H(uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int16_t ShortParameters_Class_get_I(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_I()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

void ShortParameters_Class_set_I(ShortParameters_Class* object, int16_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_I(int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int16_t ShortParameters_Class_get_J(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_J()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

void ShortParameters_Class_set_J(ShortParameters_Class* object, int16_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_J(int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

uint16_t ShortParameters_Class_get_K(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_K()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

void ShortParameters_Class_set_K(ShortParameters_Class* object, uint16_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_K(uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

uint16_t ShortParameters_Class_get_L(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_L()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

void ShortParameters_Class_set_L(ShortParameters_Class* object, uint16_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_L(uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int64_t ShortParameters_Class_get_M(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_M()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

void ShortParameters_Class_set_M(ShortParameters_Class* object, int64_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_M(long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int64_t ShortParameters_Class_get_N(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_N()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

void ShortParameters_Class_set_N(ShortParameters_Class* object, int64_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_N(long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

uint64_t ShortParameters_Class_get_O(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_O()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

void ShortParameters_Class_set_O(ShortParameters_Class* object, uint64_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_O(ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

uint64_t ShortParameters_Class_get_P(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_P()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

void ShortParameters_Class_set_P(ShortParameters_Class* object, uint64_t value)
{
    const char __method_name[] = "ShortParameters.Class:set_P(ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

gunichar2 ShortParameters_Class_get_Q(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_Q()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

void ShortParameters_Class_set_Q(ShortParameters_Class* object, gunichar2 value)
{
    const char __method_name[] = "ShortParameters.Class:set_Q(char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

gunichar2 ShortParameters_Class_get_R(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_R()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

void ShortParameters_Class_set_R(ShortParameters_Class* object, gunichar2 value)
{
    const char __method_name[] = "ShortParameters.Class:set_R(char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

bool ShortParameters_Class_get_S(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_S()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

void ShortParameters_Class_set_S(ShortParameters_Class* object, bool value)
{
    const char __method_name[] = "ShortParameters.Class:set_S(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

bool ShortParameters_Class_get_T(ShortParameters_Class* object)
{
    const char __method_name[] = "ShortParameters.Class:get_T()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

void ShortParameters_Class_set_T(ShortParameters_Class* object, bool value)
{
    const char __method_name[] = "ShortParameters.Class:set_T(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

bool ShortParameters_Class_NoDuplicateTypes(ShortParameters_Class* object, const char* a, double c, float e, uint32_t g, int16_t i, uint16_t k, int64_t m, uint64_t o, gunichar2 q, bool s)
{
    const char __method_name[] = "ShortParameters.Class:NoDuplicateTypes(string,double,single,uint,int16,uint16,long,ulong,char,bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[10];
    MonoString* __a_0 = (a) ? mono_string_new(__mono_context.domain, a) : 0;
    __args[0] = __a_0;
    __args[1] = &c;
    __args[2] = &e;
    __args[3] = &g;
    __args[4] = &i;
    __args[5] = &k;
    __args[6] = &m;
    __args[7] = &o;
    __args[8] = &q;
    __args[9] = &s;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

int32_t ShortParameters_Class_TwoInt(ShortParameters_Class* object, int32_t x, int32_t y)
{
    const char __method_name[] = "ShortParameters.Class:TwoInt(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &x;
    __args[1] = &y;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

const char* ShortParameters_Class_TwoString(ShortParameters_Class* object, const char* a, const char* b)
{
    const char __method_name[] = "ShortParameters.Class:TwoString(string,string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __a_0 = (a) ? mono_string_new(__mono_context.domain, a) : 0;
    __args[0] = __a_0;
    MonoString* __b_1 = (b) ? mono_string_new(__mono_context.domain, b) : 0;
    __args[1] = __b_1;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

double ShortParameters_Class_TwoDouble(ShortParameters_Class* object, double c, double d)
{
    const char __method_name[] = "ShortParameters.Class:TwoDouble(double,double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &c;
    __args[1] = &d;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((double*)__unbox);
}

float ShortParameters_Class_TwoFloat(ShortParameters_Class* object, float e, float f)
{
    const char __method_name[] = "ShortParameters.Class:TwoFloat(single,single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &e;
    __args[1] = &f;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

uint32_t ShortParameters_Class_TwoUint(ShortParameters_Class* object, uint32_t g, uint32_t h)
{
    const char __method_name[] = "ShortParameters.Class:TwoUint(uint,uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &g;
    __args[1] = &h;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

int32_t ShortParameters_Class_TwoShort(ShortParameters_Class* object, int16_t i, int16_t j)
{
    const char __method_name[] = "ShortParameters.Class:TwoShort(int16,int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &i;
    __args[1] = &j;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t ShortParameters_Class_TwoUshort(ShortParameters_Class* object, uint16_t k, uint16_t l)
{
    const char __method_name[] = "ShortParameters.Class:TwoUshort(uint16,uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &k;
    __args[1] = &l;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int64_t ShortParameters_Class_TwoLong(ShortParameters_Class* object, int64_t m, int64_t n)
{
    const char __method_name[] = "ShortParameters.Class:TwoLong(long,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &m;
    __args[1] = &n;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

uint64_t ShortParameters_Class_TwoUlong(ShortParameters_Class* object, uint64_t o, uint64_t p)
{
    const char __method_name[] = "ShortParameters.Class:TwoUlong(ulong,ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &o;
    __args[1] = &p;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

int32_t ShortParameters_Class_TwoChar(ShortParameters_Class* object, gunichar2 q, gunichar2 r)
{
    const char __method_name[] = "ShortParameters.Class:TwoChar(char,char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &q;
    __args[1] = &r;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool ShortParameters_Class_TwoBool(ShortParameters_Class* object, bool s, bool t)
{
    const char __method_name[] = "ShortParameters.Class:TwoBool(bool,bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_ShortParameters_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_ShortParameters_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &s;
    __args[1] = &t;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Subscripts_BoolCollection()
{
    if (class_Subscripts_BoolCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_BoolCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "BoolCollection");
    }
}

Subscripts_BoolCollection* Subscripts_BoolCollection_new()
{
    const char __method_name[] = "Subscripts.BoolCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolCollection);
    }

    Subscripts_BoolCollection* object = (Subscripts_BoolCollection*) calloc(1, sizeof(Subscripts_BoolCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_BoolCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_BoolCollection_Add(Subscripts_BoolCollection* object, bool item)
{
    const char __method_name[] = "Subscripts.BoolCollection:Add(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_BoolCollection_Remove(Subscripts_BoolCollection* object, bool item)
{
    const char __method_name[] = "Subscripts.BoolCollection:Remove(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_BoolCollection_get_Count(Subscripts_BoolCollection* object)
{
    const char __method_name[] = "Subscripts.BoolCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool Subscripts_BoolCollection_get_Item(Subscripts_BoolCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.BoolCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

void Subscripts_BoolCollection_set_Item(Subscripts_BoolCollection* object, int32_t index, bool value)
{
    const char __method_name[] = "Subscripts.BoolCollection:set_Item(int,bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_BoolDictionaryCollection()
{
    if (class_Subscripts_BoolDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_BoolDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "BoolDictionaryCollection");
    }
}

Subscripts_BoolDictionaryCollection* Subscripts_BoolDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.BoolDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolDictionaryCollection);
    }

    Subscripts_BoolDictionaryCollection* object = (Subscripts_BoolDictionaryCollection*) calloc(1, sizeof(Subscripts_BoolDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_BoolDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_BoolDictionaryCollection_Add(Subscripts_BoolDictionaryCollection* object, const char* key, bool item)
{
    const char __method_name[] = "Subscripts.BoolDictionaryCollection:Add(string,bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_BoolDictionaryCollection_Remove(Subscripts_BoolDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.BoolDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_BoolDictionaryCollection_get_Count(Subscripts_BoolDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.BoolDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool Subscripts_BoolDictionaryCollection_get_Item(Subscripts_BoolDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.BoolDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

void Subscripts_BoolDictionaryCollection_set_Item(Subscripts_BoolDictionaryCollection* object, const char* key, bool value)
{
    const char __method_name[] = "Subscripts.BoolDictionaryCollection:set_Item(string,bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_BoolDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_BoolDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_SbyteCollection()
{
    if (class_Subscripts_SbyteCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_SbyteCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "SbyteCollection");
    }
}

Subscripts_SbyteCollection* Subscripts_SbyteCollection_new()
{
    const char __method_name[] = "Subscripts.SbyteCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteCollection);
    }

    Subscripts_SbyteCollection* object = (Subscripts_SbyteCollection*) calloc(1, sizeof(Subscripts_SbyteCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_SbyteCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_SbyteCollection_Add(Subscripts_SbyteCollection* object, int8_t item)
{
    const char __method_name[] = "Subscripts.SbyteCollection:Add(sbyte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_SbyteCollection_Remove(Subscripts_SbyteCollection* object, int8_t item)
{
    const char __method_name[] = "Subscripts.SbyteCollection:Remove(sbyte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_SbyteCollection_get_Count(Subscripts_SbyteCollection* object)
{
    const char __method_name[] = "Subscripts.SbyteCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int8_t Subscripts_SbyteCollection_get_Item(Subscripts_SbyteCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.SbyteCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int8_t*)__unbox);
}

void Subscripts_SbyteCollection_set_Item(Subscripts_SbyteCollection* object, int32_t index, int8_t value)
{
    const char __method_name[] = "Subscripts.SbyteCollection:set_Item(int,sbyte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_SbyteDictionaryCollection()
{
    if (class_Subscripts_SbyteDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_SbyteDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "SbyteDictionaryCollection");
    }
}

Subscripts_SbyteDictionaryCollection* Subscripts_SbyteDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.SbyteDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteDictionaryCollection);
    }

    Subscripts_SbyteDictionaryCollection* object = (Subscripts_SbyteDictionaryCollection*) calloc(1, sizeof(Subscripts_SbyteDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_SbyteDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_SbyteDictionaryCollection_Add(Subscripts_SbyteDictionaryCollection* object, const char* key, int8_t item)
{
    const char __method_name[] = "Subscripts.SbyteDictionaryCollection:Add(string,sbyte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_SbyteDictionaryCollection_Remove(Subscripts_SbyteDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.SbyteDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_SbyteDictionaryCollection_get_Count(Subscripts_SbyteDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.SbyteDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int8_t Subscripts_SbyteDictionaryCollection_get_Item(Subscripts_SbyteDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.SbyteDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int8_t*)__unbox);
}

void Subscripts_SbyteDictionaryCollection_set_Item(Subscripts_SbyteDictionaryCollection* object, const char* key, int8_t value)
{
    const char __method_name[] = "Subscripts.SbyteDictionaryCollection:set_Item(string,sbyte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_SbyteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_SbyteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_ByteCollection()
{
    if (class_Subscripts_ByteCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_ByteCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "ByteCollection");
    }
}

Subscripts_ByteCollection* Subscripts_ByteCollection_new()
{
    const char __method_name[] = "Subscripts.ByteCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteCollection);
    }

    Subscripts_ByteCollection* object = (Subscripts_ByteCollection*) calloc(1, sizeof(Subscripts_ByteCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_ByteCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_ByteCollection_Add(Subscripts_ByteCollection* object, uint8_t item)
{
    const char __method_name[] = "Subscripts.ByteCollection:Add(byte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_ByteCollection_Remove(Subscripts_ByteCollection* object, uint8_t item)
{
    const char __method_name[] = "Subscripts.ByteCollection:Remove(byte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_ByteCollection_get_Count(Subscripts_ByteCollection* object)
{
    const char __method_name[] = "Subscripts.ByteCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint8_t Subscripts_ByteCollection_get_Item(Subscripts_ByteCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.ByteCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint8_t*)__unbox);
}

void Subscripts_ByteCollection_set_Item(Subscripts_ByteCollection* object, int32_t index, uint8_t value)
{
    const char __method_name[] = "Subscripts.ByteCollection:set_Item(int,byte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_ByteDictionaryCollection()
{
    if (class_Subscripts_ByteDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_ByteDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "ByteDictionaryCollection");
    }
}

Subscripts_ByteDictionaryCollection* Subscripts_ByteDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.ByteDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteDictionaryCollection);
    }

    Subscripts_ByteDictionaryCollection* object = (Subscripts_ByteDictionaryCollection*) calloc(1, sizeof(Subscripts_ByteDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_ByteDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_ByteDictionaryCollection_Add(Subscripts_ByteDictionaryCollection* object, const char* key, uint8_t item)
{
    const char __method_name[] = "Subscripts.ByteDictionaryCollection:Add(string,byte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_ByteDictionaryCollection_Remove(Subscripts_ByteDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.ByteDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_ByteDictionaryCollection_get_Count(Subscripts_ByteDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.ByteDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint8_t Subscripts_ByteDictionaryCollection_get_Item(Subscripts_ByteDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.ByteDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint8_t*)__unbox);
}

void Subscripts_ByteDictionaryCollection_set_Item(Subscripts_ByteDictionaryCollection* object, const char* key, uint8_t value)
{
    const char __method_name[] = "Subscripts.ByteDictionaryCollection:set_Item(string,byte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ByteDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ByteDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_ShortCollection()
{
    if (class_Subscripts_ShortCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_ShortCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "ShortCollection");
    }
}

Subscripts_ShortCollection* Subscripts_ShortCollection_new()
{
    const char __method_name[] = "Subscripts.ShortCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortCollection);
    }

    Subscripts_ShortCollection* object = (Subscripts_ShortCollection*) calloc(1, sizeof(Subscripts_ShortCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_ShortCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_ShortCollection_Add(Subscripts_ShortCollection* object, int16_t item)
{
    const char __method_name[] = "Subscripts.ShortCollection:Add(int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_ShortCollection_Remove(Subscripts_ShortCollection* object, int16_t item)
{
    const char __method_name[] = "Subscripts.ShortCollection:Remove(int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_ShortCollection_get_Count(Subscripts_ShortCollection* object)
{
    const char __method_name[] = "Subscripts.ShortCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int16_t Subscripts_ShortCollection_get_Item(Subscripts_ShortCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.ShortCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

void Subscripts_ShortCollection_set_Item(Subscripts_ShortCollection* object, int32_t index, int16_t value)
{
    const char __method_name[] = "Subscripts.ShortCollection:set_Item(int,int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_ShortDictionaryCollection()
{
    if (class_Subscripts_ShortDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_ShortDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "ShortDictionaryCollection");
    }
}

Subscripts_ShortDictionaryCollection* Subscripts_ShortDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.ShortDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortDictionaryCollection);
    }

    Subscripts_ShortDictionaryCollection* object = (Subscripts_ShortDictionaryCollection*) calloc(1, sizeof(Subscripts_ShortDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_ShortDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_ShortDictionaryCollection_Add(Subscripts_ShortDictionaryCollection* object, const char* key, int16_t item)
{
    const char __method_name[] = "Subscripts.ShortDictionaryCollection:Add(string,int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_ShortDictionaryCollection_Remove(Subscripts_ShortDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.ShortDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_ShortDictionaryCollection_get_Count(Subscripts_ShortDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.ShortDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int16_t Subscripts_ShortDictionaryCollection_get_Item(Subscripts_ShortDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.ShortDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int16_t*)__unbox);
}

void Subscripts_ShortDictionaryCollection_set_Item(Subscripts_ShortDictionaryCollection* object, const char* key, int16_t value)
{
    const char __method_name[] = "Subscripts.ShortDictionaryCollection:set_Item(string,int16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_ShortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_ShortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_UshortCollection()
{
    if (class_Subscripts_UshortCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_UshortCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "UshortCollection");
    }
}

Subscripts_UshortCollection* Subscripts_UshortCollection_new()
{
    const char __method_name[] = "Subscripts.UshortCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortCollection);
    }

    Subscripts_UshortCollection* object = (Subscripts_UshortCollection*) calloc(1, sizeof(Subscripts_UshortCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_UshortCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_UshortCollection_Add(Subscripts_UshortCollection* object, uint16_t item)
{
    const char __method_name[] = "Subscripts.UshortCollection:Add(uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_UshortCollection_Remove(Subscripts_UshortCollection* object, uint16_t item)
{
    const char __method_name[] = "Subscripts.UshortCollection:Remove(uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_UshortCollection_get_Count(Subscripts_UshortCollection* object)
{
    const char __method_name[] = "Subscripts.UshortCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint16_t Subscripts_UshortCollection_get_Item(Subscripts_UshortCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.UshortCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

void Subscripts_UshortCollection_set_Item(Subscripts_UshortCollection* object, int32_t index, uint16_t value)
{
    const char __method_name[] = "Subscripts.UshortCollection:set_Item(int,uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_UshortDictionaryCollection()
{
    if (class_Subscripts_UshortDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_UshortDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "UshortDictionaryCollection");
    }
}

Subscripts_UshortDictionaryCollection* Subscripts_UshortDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.UshortDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortDictionaryCollection);
    }

    Subscripts_UshortDictionaryCollection* object = (Subscripts_UshortDictionaryCollection*) calloc(1, sizeof(Subscripts_UshortDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_UshortDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_UshortDictionaryCollection_Add(Subscripts_UshortDictionaryCollection* object, const char* key, uint16_t item)
{
    const char __method_name[] = "Subscripts.UshortDictionaryCollection:Add(string,uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_UshortDictionaryCollection_Remove(Subscripts_UshortDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.UshortDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_UshortDictionaryCollection_get_Count(Subscripts_UshortDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.UshortDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint16_t Subscripts_UshortDictionaryCollection_get_Item(Subscripts_UshortDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.UshortDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint16_t*)__unbox);
}

void Subscripts_UshortDictionaryCollection_set_Item(Subscripts_UshortDictionaryCollection* object, const char* key, uint16_t value)
{
    const char __method_name[] = "Subscripts.UshortDictionaryCollection:set_Item(string,uint16)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UshortDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UshortDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_IntCollection()
{
    if (class_Subscripts_IntCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_IntCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "IntCollection");
    }
}

Subscripts_IntCollection* Subscripts_IntCollection_new()
{
    const char __method_name[] = "Subscripts.IntCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollection);
    }

    Subscripts_IntCollection* object = (Subscripts_IntCollection*) calloc(1, sizeof(Subscripts_IntCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_IntCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_IntCollection_Add(Subscripts_IntCollection* object, int32_t item)
{
    const char __method_name[] = "Subscripts.IntCollection:Add(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_IntCollection_Remove(Subscripts_IntCollection* object, int32_t item)
{
    const char __method_name[] = "Subscripts.IntCollection:Remove(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_IntCollection_get_Count(Subscripts_IntCollection* object)
{
    const char __method_name[] = "Subscripts.IntCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Subscripts_IntCollection_get_Item(Subscripts_IntCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.IntCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void Subscripts_IntCollection_set_Item(Subscripts_IntCollection* object, int32_t index, int32_t value)
{
    const char __method_name[] = "Subscripts.IntCollection:set_Item(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_IntDictionaryCollection()
{
    if (class_Subscripts_IntDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_IntDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "IntDictionaryCollection");
    }
}

Subscripts_IntDictionaryCollection* Subscripts_IntDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.IntDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntDictionaryCollection);
    }

    Subscripts_IntDictionaryCollection* object = (Subscripts_IntDictionaryCollection*) calloc(1, sizeof(Subscripts_IntDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_IntDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_IntDictionaryCollection_Add(Subscripts_IntDictionaryCollection* object, const char* key, int32_t item)
{
    const char __method_name[] = "Subscripts.IntDictionaryCollection:Add(string,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_IntDictionaryCollection_Remove(Subscripts_IntDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.IntDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_IntDictionaryCollection_get_Count(Subscripts_IntDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.IntDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Subscripts_IntDictionaryCollection_get_Item(Subscripts_IntDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.IntDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void Subscripts_IntDictionaryCollection_set_Item(Subscripts_IntDictionaryCollection* object, const char* key, int32_t value)
{
    const char __method_name[] = "Subscripts.IntDictionaryCollection:set_Item(string,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_UintCollection()
{
    if (class_Subscripts_UintCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_UintCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "UintCollection");
    }
}

Subscripts_UintCollection* Subscripts_UintCollection_new()
{
    const char __method_name[] = "Subscripts.UintCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintCollection);
    }

    Subscripts_UintCollection* object = (Subscripts_UintCollection*) calloc(1, sizeof(Subscripts_UintCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_UintCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_UintCollection_Add(Subscripts_UintCollection* object, uint32_t item)
{
    const char __method_name[] = "Subscripts.UintCollection:Add(uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_UintCollection_Remove(Subscripts_UintCollection* object, uint32_t item)
{
    const char __method_name[] = "Subscripts.UintCollection:Remove(uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_UintCollection_get_Count(Subscripts_UintCollection* object)
{
    const char __method_name[] = "Subscripts.UintCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint32_t Subscripts_UintCollection_get_Item(Subscripts_UintCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.UintCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

void Subscripts_UintCollection_set_Item(Subscripts_UintCollection* object, int32_t index, uint32_t value)
{
    const char __method_name[] = "Subscripts.UintCollection:set_Item(int,uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_UintDictionaryCollection()
{
    if (class_Subscripts_UintDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_UintDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "UintDictionaryCollection");
    }
}

Subscripts_UintDictionaryCollection* Subscripts_UintDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.UintDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintDictionaryCollection);
    }

    Subscripts_UintDictionaryCollection* object = (Subscripts_UintDictionaryCollection*) calloc(1, sizeof(Subscripts_UintDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_UintDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_UintDictionaryCollection_Add(Subscripts_UintDictionaryCollection* object, const char* key, uint32_t item)
{
    const char __method_name[] = "Subscripts.UintDictionaryCollection:Add(string,uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_UintDictionaryCollection_Remove(Subscripts_UintDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.UintDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_UintDictionaryCollection_get_Count(Subscripts_UintDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.UintDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint32_t Subscripts_UintDictionaryCollection_get_Item(Subscripts_UintDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.UintDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint32_t*)__unbox);
}

void Subscripts_UintDictionaryCollection_set_Item(Subscripts_UintDictionaryCollection* object, const char* key, uint32_t value)
{
    const char __method_name[] = "Subscripts.UintDictionaryCollection:set_Item(string,uint)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UintDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UintDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_LongCollection()
{
    if (class_Subscripts_LongCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_LongCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "LongCollection");
    }
}

Subscripts_LongCollection* Subscripts_LongCollection_new()
{
    const char __method_name[] = "Subscripts.LongCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongCollection);
    }

    Subscripts_LongCollection* object = (Subscripts_LongCollection*) calloc(1, sizeof(Subscripts_LongCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_LongCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_LongCollection_Add(Subscripts_LongCollection* object, int64_t item)
{
    const char __method_name[] = "Subscripts.LongCollection:Add(long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_LongCollection_Remove(Subscripts_LongCollection* object, int64_t item)
{
    const char __method_name[] = "Subscripts.LongCollection:Remove(long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_LongCollection_get_Count(Subscripts_LongCollection* object)
{
    const char __method_name[] = "Subscripts.LongCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int64_t Subscripts_LongCollection_get_Item(Subscripts_LongCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.LongCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

void Subscripts_LongCollection_set_Item(Subscripts_LongCollection* object, int32_t index, int64_t value)
{
    const char __method_name[] = "Subscripts.LongCollection:set_Item(int,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_LongDictionaryCollection()
{
    if (class_Subscripts_LongDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_LongDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "LongDictionaryCollection");
    }
}

Subscripts_LongDictionaryCollection* Subscripts_LongDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.LongDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongDictionaryCollection);
    }

    Subscripts_LongDictionaryCollection* object = (Subscripts_LongDictionaryCollection*) calloc(1, sizeof(Subscripts_LongDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_LongDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_LongDictionaryCollection_Add(Subscripts_LongDictionaryCollection* object, const char* key, int64_t item)
{
    const char __method_name[] = "Subscripts.LongDictionaryCollection:Add(string,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_LongDictionaryCollection_Remove(Subscripts_LongDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.LongDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_LongDictionaryCollection_get_Count(Subscripts_LongDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.LongDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int64_t Subscripts_LongDictionaryCollection_get_Item(Subscripts_LongDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.LongDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

void Subscripts_LongDictionaryCollection_set_Item(Subscripts_LongDictionaryCollection* object, const char* key, int64_t value)
{
    const char __method_name[] = "Subscripts.LongDictionaryCollection:set_Item(string,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_LongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_LongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_UlongCollection()
{
    if (class_Subscripts_UlongCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_UlongCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "UlongCollection");
    }
}

Subscripts_UlongCollection* Subscripts_UlongCollection_new()
{
    const char __method_name[] = "Subscripts.UlongCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongCollection);
    }

    Subscripts_UlongCollection* object = (Subscripts_UlongCollection*) calloc(1, sizeof(Subscripts_UlongCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_UlongCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_UlongCollection_Add(Subscripts_UlongCollection* object, uint64_t item)
{
    const char __method_name[] = "Subscripts.UlongCollection:Add(ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_UlongCollection_Remove(Subscripts_UlongCollection* object, uint64_t item)
{
    const char __method_name[] = "Subscripts.UlongCollection:Remove(ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_UlongCollection_get_Count(Subscripts_UlongCollection* object)
{
    const char __method_name[] = "Subscripts.UlongCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint64_t Subscripts_UlongCollection_get_Item(Subscripts_UlongCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.UlongCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

void Subscripts_UlongCollection_set_Item(Subscripts_UlongCollection* object, int32_t index, uint64_t value)
{
    const char __method_name[] = "Subscripts.UlongCollection:set_Item(int,ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_UlongDictionaryCollection()
{
    if (class_Subscripts_UlongDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_UlongDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "UlongDictionaryCollection");
    }
}

Subscripts_UlongDictionaryCollection* Subscripts_UlongDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.UlongDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongDictionaryCollection);
    }

    Subscripts_UlongDictionaryCollection* object = (Subscripts_UlongDictionaryCollection*) calloc(1, sizeof(Subscripts_UlongDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_UlongDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_UlongDictionaryCollection_Add(Subscripts_UlongDictionaryCollection* object, const char* key, uint64_t item)
{
    const char __method_name[] = "Subscripts.UlongDictionaryCollection:Add(string,ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_UlongDictionaryCollection_Remove(Subscripts_UlongDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.UlongDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_UlongDictionaryCollection_get_Count(Subscripts_UlongDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.UlongDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

uint64_t Subscripts_UlongDictionaryCollection_get_Item(Subscripts_UlongDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.UlongDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((uint64_t*)__unbox);
}

void Subscripts_UlongDictionaryCollection_set_Item(Subscripts_UlongDictionaryCollection* object, const char* key, uint64_t value)
{
    const char __method_name[] = "Subscripts.UlongDictionaryCollection:set_Item(string,ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_UlongDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_UlongDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_FloatCollection()
{
    if (class_Subscripts_FloatCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_FloatCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "FloatCollection");
    }
}

Subscripts_FloatCollection* Subscripts_FloatCollection_new()
{
    const char __method_name[] = "Subscripts.FloatCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatCollection);
    }

    Subscripts_FloatCollection* object = (Subscripts_FloatCollection*) calloc(1, sizeof(Subscripts_FloatCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_FloatCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_FloatCollection_Add(Subscripts_FloatCollection* object, float item)
{
    const char __method_name[] = "Subscripts.FloatCollection:Add(single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_FloatCollection_Remove(Subscripts_FloatCollection* object, float item)
{
    const char __method_name[] = "Subscripts.FloatCollection:Remove(single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_FloatCollection_get_Count(Subscripts_FloatCollection* object)
{
    const char __method_name[] = "Subscripts.FloatCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

float Subscripts_FloatCollection_get_Item(Subscripts_FloatCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.FloatCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

void Subscripts_FloatCollection_set_Item(Subscripts_FloatCollection* object, int32_t index, float value)
{
    const char __method_name[] = "Subscripts.FloatCollection:set_Item(int,single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_FloatDictionaryCollection()
{
    if (class_Subscripts_FloatDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_FloatDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "FloatDictionaryCollection");
    }
}

Subscripts_FloatDictionaryCollection* Subscripts_FloatDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.FloatDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatDictionaryCollection);
    }

    Subscripts_FloatDictionaryCollection* object = (Subscripts_FloatDictionaryCollection*) calloc(1, sizeof(Subscripts_FloatDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_FloatDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_FloatDictionaryCollection_Add(Subscripts_FloatDictionaryCollection* object, const char* key, float item)
{
    const char __method_name[] = "Subscripts.FloatDictionaryCollection:Add(string,single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_FloatDictionaryCollection_Remove(Subscripts_FloatDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.FloatDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_FloatDictionaryCollection_get_Count(Subscripts_FloatDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.FloatDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

float Subscripts_FloatDictionaryCollection_get_Item(Subscripts_FloatDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.FloatDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

void Subscripts_FloatDictionaryCollection_set_Item(Subscripts_FloatDictionaryCollection* object, const char* key, float value)
{
    const char __method_name[] = "Subscripts.FloatDictionaryCollection:set_Item(string,single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_FloatDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_FloatDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_DoubleCollection()
{
    if (class_Subscripts_DoubleCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_DoubleCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "DoubleCollection");
    }
}

Subscripts_DoubleCollection* Subscripts_DoubleCollection_new()
{
    const char __method_name[] = "Subscripts.DoubleCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleCollection);
    }

    Subscripts_DoubleCollection* object = (Subscripts_DoubleCollection*) calloc(1, sizeof(Subscripts_DoubleCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_DoubleCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_DoubleCollection_Add(Subscripts_DoubleCollection* object, double item)
{
    const char __method_name[] = "Subscripts.DoubleCollection:Add(double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_DoubleCollection_Remove(Subscripts_DoubleCollection* object, double item)
{
    const char __method_name[] = "Subscripts.DoubleCollection:Remove(double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_DoubleCollection_get_Count(Subscripts_DoubleCollection* object)
{
    const char __method_name[] = "Subscripts.DoubleCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

double Subscripts_DoubleCollection_get_Item(Subscripts_DoubleCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.DoubleCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((double*)__unbox);
}

void Subscripts_DoubleCollection_set_Item(Subscripts_DoubleCollection* object, int32_t index, double value)
{
    const char __method_name[] = "Subscripts.DoubleCollection:set_Item(int,double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_DoubleDictionaryCollection()
{
    if (class_Subscripts_DoubleDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_DoubleDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "DoubleDictionaryCollection");
    }
}

Subscripts_DoubleDictionaryCollection* Subscripts_DoubleDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.DoubleDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleDictionaryCollection);
    }

    Subscripts_DoubleDictionaryCollection* object = (Subscripts_DoubleDictionaryCollection*) calloc(1, sizeof(Subscripts_DoubleDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_DoubleDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_DoubleDictionaryCollection_Add(Subscripts_DoubleDictionaryCollection* object, const char* key, double item)
{
    const char __method_name[] = "Subscripts.DoubleDictionaryCollection:Add(string,double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_DoubleDictionaryCollection_Remove(Subscripts_DoubleDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.DoubleDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_DoubleDictionaryCollection_get_Count(Subscripts_DoubleDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.DoubleDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

double Subscripts_DoubleDictionaryCollection_get_Item(Subscripts_DoubleDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.DoubleDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((double*)__unbox);
}

void Subscripts_DoubleDictionaryCollection_set_Item(Subscripts_DoubleDictionaryCollection* object, const char* key, double value)
{
    const char __method_name[] = "Subscripts.DoubleDictionaryCollection:set_Item(string,double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_DoubleDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_DoubleDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_CharCollection()
{
    if (class_Subscripts_CharCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_CharCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "CharCollection");
    }
}

Subscripts_CharCollection* Subscripts_CharCollection_new()
{
    const char __method_name[] = "Subscripts.CharCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharCollection);
    }

    Subscripts_CharCollection* object = (Subscripts_CharCollection*) calloc(1, sizeof(Subscripts_CharCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_CharCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_CharCollection_Add(Subscripts_CharCollection* object, gunichar2 item)
{
    const char __method_name[] = "Subscripts.CharCollection:Add(char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_CharCollection_Remove(Subscripts_CharCollection* object, gunichar2 item)
{
    const char __method_name[] = "Subscripts.CharCollection:Remove(char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_CharCollection_get_Count(Subscripts_CharCollection* object)
{
    const char __method_name[] = "Subscripts.CharCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

gunichar2 Subscripts_CharCollection_get_Item(Subscripts_CharCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.CharCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

void Subscripts_CharCollection_set_Item(Subscripts_CharCollection* object, int32_t index, gunichar2 value)
{
    const char __method_name[] = "Subscripts.CharCollection:set_Item(int,char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_CharDictionaryCollection()
{
    if (class_Subscripts_CharDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_CharDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "CharDictionaryCollection");
    }
}

Subscripts_CharDictionaryCollection* Subscripts_CharDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.CharDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharDictionaryCollection);
    }

    Subscripts_CharDictionaryCollection* object = (Subscripts_CharDictionaryCollection*) calloc(1, sizeof(Subscripts_CharDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_CharDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_CharDictionaryCollection_Add(Subscripts_CharDictionaryCollection* object, const char* key, gunichar2 item)
{
    const char __method_name[] = "Subscripts.CharDictionaryCollection:Add(string,char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &item;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_CharDictionaryCollection_Remove(Subscripts_CharDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.CharDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_CharDictionaryCollection_get_Count(Subscripts_CharDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.CharDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

gunichar2 Subscripts_CharDictionaryCollection_get_Item(Subscripts_CharDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.CharDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((gunichar2*)__unbox);
}

void Subscripts_CharDictionaryCollection_set_Item(Subscripts_CharDictionaryCollection* object, const char* key, gunichar2 value)
{
    const char __method_name[] = "Subscripts.CharDictionaryCollection:set_Item(string,char)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_CharDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_CharDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_StringCollection()
{
    if (class_Subscripts_StringCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_StringCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "StringCollection");
    }
}

Subscripts_StringCollection* Subscripts_StringCollection_new()
{
    const char __method_name[] = "Subscripts.StringCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringCollection);
    }

    Subscripts_StringCollection* object = (Subscripts_StringCollection*) calloc(1, sizeof(Subscripts_StringCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_StringCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_StringCollection_Add(Subscripts_StringCollection* object, const char* item)
{
    const char __method_name[] = "Subscripts.StringCollection:Add(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __item_0 = (item) ? mono_string_new(__mono_context.domain, item) : 0;
    __args[0] = __item_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_StringCollection_Remove(Subscripts_StringCollection* object, const char* item)
{
    const char __method_name[] = "Subscripts.StringCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __item_0 = (item) ? mono_string_new(__mono_context.domain, item) : 0;
    __args[0] = __item_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_StringCollection_get_Count(Subscripts_StringCollection* object)
{
    const char __method_name[] = "Subscripts.StringCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

const char* Subscripts_StringCollection_get_Item(Subscripts_StringCollection* object, int32_t index)
{
    const char __method_name[] = "Subscripts.StringCollection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

void Subscripts_StringCollection_set_Item(Subscripts_StringCollection* object, int32_t index, const char* value)
{
    const char __method_name[] = "Subscripts.StringCollection:set_Item(int,string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    MonoString* __value_1 = (value) ? mono_string_new(__mono_context.domain, value) : 0;
    __args[1] = __value_1;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_StringDictionaryCollection()
{
    if (class_Subscripts_StringDictionaryCollection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_StringDictionaryCollection = mono_class_from_name(__managed_dll_image, "Subscripts", "StringDictionaryCollection");
    }
}

Subscripts_StringDictionaryCollection* Subscripts_StringDictionaryCollection_new()
{
    const char __method_name[] = "Subscripts.StringDictionaryCollection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringDictionaryCollection);
    }

    Subscripts_StringDictionaryCollection* object = (Subscripts_StringDictionaryCollection*) calloc(1, sizeof(Subscripts_StringDictionaryCollection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_StringDictionaryCollection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_StringDictionaryCollection_Add(Subscripts_StringDictionaryCollection* object, const char* key, const char* item)
{
    const char __method_name[] = "Subscripts.StringDictionaryCollection:Add(string,string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoString* __item_1 = (item) ? mono_string_new(__mono_context.domain, item) : 0;
    __args[1] = __item_1;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Subscripts_StringDictionaryCollection_Remove(Subscripts_StringDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.StringDictionaryCollection:Remove(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Subscripts_StringDictionaryCollection_get_Count(Subscripts_StringDictionaryCollection* object)
{
    const char __method_name[] = "Subscripts.StringDictionaryCollection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

const char* Subscripts_StringDictionaryCollection_get_Item(Subscripts_StringDictionaryCollection* object, const char* key)
{
    const char __method_name[] = "Subscripts.StringDictionaryCollection:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

void Subscripts_StringDictionaryCollection_set_Item(Subscripts_StringDictionaryCollection* object, const char* key, const char* value)
{
    const char __method_name[] = "Subscripts.StringDictionaryCollection:set_Item(string,string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_StringDictionaryCollection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_StringDictionaryCollection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __key_0 = (key) ? mono_string_new(__mono_context.domain, key) : 0;
    __args[0] = __key_0;
    MonoString* __value_1 = (value) ? mono_string_new(__mono_context.domain, value) : 0;
    __args[1] = __value_1;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Subscripts_IntCollectionNoSetter()
{
    if (class_Subscripts_IntCollectionNoSetter == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_IntCollectionNoSetter = mono_class_from_name(__managed_dll_image, "Subscripts", "IntCollectionNoSetter");
    }
}

Subscripts_IntCollectionNoSetter* Subscripts_IntCollectionNoSetter_new()
{
    const char __method_name[] = "Subscripts.IntCollectionNoSetter:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollectionNoSetter();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollectionNoSetter);
    }

    Subscripts_IntCollectionNoSetter* object = (Subscripts_IntCollectionNoSetter*) calloc(1, sizeof(Subscripts_IntCollectionNoSetter));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_IntCollectionNoSetter);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Subscripts_IntCollectionNoSetter_get_Item(Subscripts_IntCollectionNoSetter* object, int32_t index)
{
    const char __method_name[] = "Subscripts.IntCollectionNoSetter:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollectionNoSetter();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollectionNoSetter);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Subscripts_IntCollectionNoGetter()
{
    if (class_Subscripts_IntCollectionNoGetter == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Subscripts_IntCollectionNoGetter = mono_class_from_name(__managed_dll_image, "Subscripts", "IntCollectionNoGetter");
    }
}

Subscripts_IntCollectionNoGetter* Subscripts_IntCollectionNoGetter_new()
{
    const char __method_name[] = "Subscripts.IntCollectionNoGetter:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollectionNoGetter();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollectionNoGetter);
    }

    Subscripts_IntCollectionNoGetter* object = (Subscripts_IntCollectionNoGetter*) calloc(1, sizeof(Subscripts_IntCollectionNoGetter));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Subscripts_IntCollectionNoGetter);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Subscripts_IntCollectionNoGetter_set_Item(Subscripts_IntCollectionNoGetter* object, int32_t index, int32_t value)
{
    const char __method_name[] = "Subscripts.IntCollectionNoGetter:set_Item(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Subscripts_IntCollectionNoGetter();
        __method = mono_embeddinator_lookup_method(__method_name, class_Subscripts_IntCollectionNoGetter);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Structs_Point()
{
    if (class_Structs_Point == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Structs_Point = mono_class_from_name(__managed_dll_image, "Structs", "Point");
    }
}

Structs_Point* Structs_Point_new(float x, float y)
{
    const char __method_name[] = "Structs.Point:.ctor(single,single)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Structs_Point();
        __method = mono_embeddinator_lookup_method(__method_name, class_Structs_Point);
    }

    Structs_Point* object = (Structs_Point*) calloc(1, sizeof(Structs_Point));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Structs_Point);
    mono_embeddinator_init_object(object, __instance);

    void* __args[2];
    __args[0] = &x;
    __args[1] = &y;
    MonoObject* __exception = 0;
    MonoObject* __result;
    void* __unboxed = mono_object_unbox(__instance);
    __result = mono_runtime_invoke(__method, __unboxed, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

float Structs_Point_get_X(Structs_Point* object)
{
    const char __method_name[] = "Structs.Point:get_X()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Structs_Point();
        __method = mono_embeddinator_lookup_method(__method_name, class_Structs_Point);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    void* __unboxed = mono_object_unbox(__instance);
    __result = mono_runtime_invoke(__method, __unboxed, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

float Structs_Point_get_Y(Structs_Point* object)
{
    const char __method_name[] = "Structs.Point:get_Y()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Structs_Point();
        __method = mono_embeddinator_lookup_method(__method_name, class_Structs_Point);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    void* __unboxed = mono_object_unbox(__instance);
    __result = mono_runtime_invoke(__method, __unboxed, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((float*)__unbox);
}

bool Structs_Point_op_Equality(Structs_Point* left, Structs_Point* right)
{
    const char __method_name[] = "Structs.Point:op_Equality(Structs.Point,Structs.Point)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Structs_Point();
        __method = mono_embeddinator_lookup_method(__method_name, class_Structs_Point);
    }


    void* __args[2];
    __args[0] = mono_object_unbox(left ? mono_gchandle_get_target(left->_handle) : 0);
    __args[1] = mono_object_unbox(right ? mono_gchandle_get_target(right->_handle) : 0);
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

bool Structs_Point_op_Inequality(Structs_Point* left, Structs_Point* right)
{
    const char __method_name[] = "Structs.Point:op_Inequality(Structs.Point,Structs.Point)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Structs_Point();
        __method = mono_embeddinator_lookup_method(__method_name, class_Structs_Point);
    }


    void* __args[2];
    __args[0] = mono_object_unbox(left ? mono_gchandle_get_target(left->_handle) : 0);
    __args[1] = mono_object_unbox(right ? mono_gchandle_get_target(right->_handle) : 0);
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

Structs_Point* Structs_Point_op_Addition(Structs_Point* left, Structs_Point* right)
{
    const char __method_name[] = "Structs.Point:op_Addition(Structs.Point,Structs.Point)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Structs_Point();
        __method = mono_embeddinator_lookup_method(__method_name, class_Structs_Point);
    }


    void* __args[2];
    __args[0] = mono_object_unbox(left ? mono_gchandle_get_target(left->_handle) : 0);
    __args[1] = mono_object_unbox(right ? mono_gchandle_get_target(right->_handle) : 0);
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Structs_Point* __result_obj = __result ? (Structs_Point*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Structs_Point* Structs_Point_op_Subtraction(Structs_Point* left, Structs_Point* right)
{
    const char __method_name[] = "Structs.Point:op_Subtraction(Structs.Point,Structs.Point)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Structs_Point();
        __method = mono_embeddinator_lookup_method(__method_name, class_Structs_Point);
    }


    void* __args[2];
    __args[0] = mono_object_unbox(left ? mono_gchandle_get_target(left->_handle) : 0);
    __args[1] = mono_object_unbox(right ? mono_gchandle_get_target(right->_handle) : 0);
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Structs_Point* __result_obj = __result ? (Structs_Point*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Structs_Point* Structs_Point_get_Zero()
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Structs_Point();
        const char __field_name[] = "Zero";
        __field = mono_class_get_field_from_name(class_Structs_Point, __field_name);
    }
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, 0);
    Structs_Point* __result_obj = __result ? (Structs_Point*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void Structs_Point_set_Zero(Structs_Point* value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Structs_Point();
        const char __field_name[] = "Zero";
        __field = mono_class_get_field_from_name(class_Structs_Point, __field_name);
    }
    void* __value = mono_object_unbox(value ? mono_gchandle_get_target(value->_handle) : 0);
    MonoVTable* __vtable = mono_class_vtable(__mono_context.domain, class_Structs_Point);
    mono_field_static_set_value(__vtable, __field, __value);
}

static void __lookup_class_Properties_Query()
{
    if (class_Properties_Query == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Properties_Query = mono_class_from_name(__managed_dll_image, "Properties", "Query");
    }
}

Properties_Query* Properties_Query_new()
{
    const char __method_name[] = "Properties.Query:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }

    Properties_Query* object = (Properties_Query*) calloc(1, sizeof(Properties_Query));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Properties_Query);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Properties_Query_get_UniversalAnswer()
{
    const char __method_name[] = "Properties.Query:get_UniversalAnswer()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool Properties_Query_get_IsGood(Properties_Query* object)
{
    const char __method_name[] = "Properties.Query:get_IsGood()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

bool Properties_Query_get_IsBad(Properties_Query* object)
{
    const char __method_name[] = "Properties.Query:get_IsBad()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

int32_t Properties_Query_get_Answer(Properties_Query* object)
{
    const char __method_name[] = "Properties.Query:get_Answer()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void Properties_Query_set_Answer(Properties_Query* object, int32_t value)
{
    const char __method_name[] = "Properties.Query:set_Answer(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Properties_Query_set_Secret(Properties_Query* object, int32_t value)
{
    const char __method_name[] = "Properties.Query:set_Secret(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

bool Properties_Query_get_IsSecret(Properties_Query* object)
{
    const char __method_name[] = "Properties.Query:get_IsSecret()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_Query();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_Query);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Properties_DuplicateIndexedProperties()
{
    if (class_Properties_DuplicateIndexedProperties == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Properties_DuplicateIndexedProperties = mono_class_from_name(__managed_dll_image, "Properties", "DuplicateIndexedProperties");
    }
}

Properties_DuplicateIndexedProperties* Properties_DuplicateIndexedProperties_new()
{
    const char __method_name[] = "Properties.DuplicateIndexedProperties:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_DuplicateIndexedProperties();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_DuplicateIndexedProperties);
    }

    Properties_DuplicateIndexedProperties* object = (Properties_DuplicateIndexedProperties*) calloc(1, sizeof(Properties_DuplicateIndexedProperties));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Properties_DuplicateIndexedProperties);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Properties_DuplicateIndexedProperties_get_Item(Properties_DuplicateIndexedProperties* object, int32_t i)
{
    const char __method_name[] = "Properties.DuplicateIndexedProperties:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_DuplicateIndexedProperties();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_DuplicateIndexedProperties);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &i;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Properties_DuplicateIndexedProperties_get_Item_1(Properties_DuplicateIndexedProperties* object, const char* i)
{
    const char __method_name[] = "Properties.DuplicateIndexedProperties:get_Item(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Properties_DuplicateIndexedProperties();
        __method = mono_embeddinator_lookup_method(__method_name, class_Properties_DuplicateIndexedProperties);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __i_0 = (i) ? mono_string_new(__mono_context.domain, i) : 0;
    __args[0] = __i_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_First_ClassWithSingleNamespace()
{
    if (class_First_ClassWithSingleNamespace == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_First_ClassWithSingleNamespace = mono_class_from_name(__managed_dll_image, "First", "ClassWithSingleNamespace");
    }
}

First_ClassWithSingleNamespace* First_ClassWithSingleNamespace_new()
{
    const char __method_name[] = "First.ClassWithSingleNamespace:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_First_ClassWithSingleNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_First_ClassWithSingleNamespace);
    }

    First_ClassWithSingleNamespace* object = (First_ClassWithSingleNamespace*) calloc(1, sizeof(First_ClassWithSingleNamespace));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_First_ClassWithSingleNamespace);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

const char* First_ClassWithSingleNamespace_ToString(First_ClassWithSingleNamespace* object)
{
    const char __method_name[] = "First.ClassWithSingleNamespace:ToString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_First_ClassWithSingleNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_First_ClassWithSingleNamespace);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_First_Second_ClassWithNestedNamespace()
{
    if (class_First_Second_ClassWithNestedNamespace == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_First_Second_ClassWithNestedNamespace = mono_class_from_name(__managed_dll_image, "First.Second", "ClassWithNestedNamespace");
    }
}

First_Second_ClassWithNestedNamespace* First_Second_ClassWithNestedNamespace_new()
{
    const char __method_name[] = "First.Second.ClassWithNestedNamespace:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_First_Second_ClassWithNestedNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_First_Second_ClassWithNestedNamespace);
    }

    First_Second_ClassWithNestedNamespace* object = (First_Second_ClassWithNestedNamespace*) calloc(1, sizeof(First_Second_ClassWithNestedNamespace));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_First_Second_ClassWithNestedNamespace);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

const char* First_Second_ClassWithNestedNamespace_ToString(First_Second_ClassWithNestedNamespace* object)
{
    const char __method_name[] = "First.Second.ClassWithNestedNamespace:ToString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_First_Second_ClassWithNestedNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_First_Second_ClassWithNestedNamespace);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_First_Second_Third_ClassWithNestedNamespace()
{
    if (class_First_Second_Third_ClassWithNestedNamespace == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_First_Second_Third_ClassWithNestedNamespace = mono_class_from_name(__managed_dll_image, "First.Second.Third", "ClassWithNestedNamespace");
    }
}

First_Second_Third_ClassWithNestedNamespace* First_Second_Third_ClassWithNestedNamespace_new()
{
    const char __method_name[] = "First.Second.Third.ClassWithNestedNamespace:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_First_Second_Third_ClassWithNestedNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_First_Second_Third_ClassWithNestedNamespace);
    }

    First_Second_Third_ClassWithNestedNamespace* object = (First_Second_Third_ClassWithNestedNamespace*) calloc(1, sizeof(First_Second_Third_ClassWithNestedNamespace));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_First_Second_Third_ClassWithNestedNamespace);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

const char* First_Second_Third_ClassWithNestedNamespace_ToString(First_Second_Third_ClassWithNestedNamespace* object)
{
    const char __method_name[] = "First.Second.Third.ClassWithNestedNamespace:ToString()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_First_Second_Third_ClassWithNestedNamespace();
        __method = mono_embeddinator_lookup_method(__method_name, class_First_Second_Third_ClassWithNestedNamespace);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_Methods_Static()
{
    if (class_Methods_Static == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Methods_Static = mono_class_from_name(__managed_dll_image, "Methods", "Static");
    }
}

Methods_Static* Methods_Static_Create(int32_t id)
{
    const char __method_name[] = "Methods.Static:Create(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Static();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Static);
    }


    void* __args[1];
    __args[0] = &id;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Methods_Static* __result_obj = __result ? (Methods_Static*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

int32_t Methods_Static_get_Id(Methods_Static* object)
{
    const char __method_name[] = "Methods.Static:get_Id()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Static();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Static);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Methods_Parameters()
{
    if (class_Methods_Parameters == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Methods_Parameters = mono_class_from_name(__managed_dll_image, "Methods", "Parameters");
    }
}

Methods_Parameters* Methods_Parameters_new()
{
    const char __method_name[] = "Methods.Parameters:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Parameters();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Parameters);
    }

    Methods_Parameters* object = (Methods_Parameters*) calloc(1, sizeof(Methods_Parameters));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Methods_Parameters);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

const char* Methods_Parameters_Concat(const char* first, const char* second)
{
    const char __method_name[] = "Methods.Parameters:Concat(string,string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Parameters();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Parameters);
    }


    void* __args[2];
    MonoString* __first_0 = (first) ? mono_string_new(__mono_context.domain, first) : 0;
    __args[0] = __first_0;
    MonoString* __second_1 = (second) ? mono_string_new(__mono_context.domain, second) : 0;
    __args[1] = __second_1;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

void Methods_Parameters_Ref(bool* boolean, GString* string)
{
    const char __method_name[] = "Methods.Parameters:Ref(bool&,string&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Parameters();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Parameters);
    }


    void* __args[2];
    __args[0] = boolean;
    MonoString* __string_1 = (string->str) ? mono_string_new(__mono_context.domain, string->str) : 0;
    __args[1] = &__string_1;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }
    mono_embeddinator_marshal_string_to_gstring(string, __string_1);

}

void Methods_Parameters_Out(const char* string, int32_t* length, GString* upper)
{
    const char __method_name[] = "Methods.Parameters:Out(string,int&,string&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Parameters();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Parameters);
    }


    void* __args[3];
    MonoString* __string_0 = (string) ? mono_string_new(__mono_context.domain, string) : 0;
    __args[0] = __string_0;
    __args[1] = length;
    MonoString* __upper_2 = (upper->str) ? mono_string_new(__mono_context.domain, upper->str) : 0;
    __args[2] = &__upper_2;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }
    mono_embeddinator_marshal_string_to_gstring(upper, __upper_2);

}

static void __lookup_class_Methods_Item()
{
    if (class_Methods_Item == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Methods_Item = mono_class_from_name(__managed_dll_image, "Methods", "Item");
    }
}

int32_t Methods_Item_get_Integer(Methods_Item* object)
{
    const char __method_name[] = "Methods.Item:get_Integer()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Item();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Item);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Methods_Factory()
{
    if (class_Methods_Factory == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Methods_Factory = mono_class_from_name(__managed_dll_image, "Methods", "Factory");
    }
}

Methods_Item* Methods_Factory_CreateItem(int32_t id)
{
    const char __method_name[] = "Methods.Factory:CreateItem(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Factory();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Factory);
    }


    void* __args[1];
    __args[0] = &id;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Methods_Item* __result_obj = __result ? (Methods_Item*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

Methods_Item* Methods_Factory_ReturnNull()
{
    const char __method_name[] = "Methods.Factory:ReturnNull()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Factory();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Factory);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Methods_Item* __result_obj = __result ? (Methods_Item*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

static void __lookup_class_Methods_Collection()
{
    if (class_Methods_Collection == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Methods_Collection = mono_class_from_name(__managed_dll_image, "Methods", "Collection");
    }
}

Methods_Collection* Methods_Collection_new()
{
    const char __method_name[] = "Methods.Collection:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Collection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Collection);
    }

    Methods_Collection* object = (Methods_Collection*) calloc(1, sizeof(Methods_Collection));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Methods_Collection);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

void Methods_Collection_Add(Methods_Collection* object, Methods_Item* item)
{
    const char __method_name[] = "Methods.Collection:Add(Methods.Item)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Collection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Collection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = item ? mono_gchandle_get_target(item->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

void Methods_Collection_Remove(Methods_Collection* object, Methods_Item* item)
{
    const char __method_name[] = "Methods.Collection:Remove(Methods.Item)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Collection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Collection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = item ? mono_gchandle_get_target(item->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

int32_t Methods_Collection_get_Count(Methods_Collection* object)
{
    const char __method_name[] = "Methods.Collection:get_Count()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Collection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Collection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

Methods_Item* Methods_Collection_get_Item(Methods_Collection* object, int32_t index)
{
    const char __method_name[] = "Methods.Collection:get_Item(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Collection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Collection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &index;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    Methods_Item* __result_obj = __result ? (Methods_Item*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void Methods_Collection_set_Item(Methods_Collection* object, int32_t index, Methods_Item* value)
{
    const char __method_name[] = "Methods.Collection:set_Item(int,Methods.Item)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_Collection();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_Collection);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &index;
    __args[1] = value ? mono_gchandle_get_target(value->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_Methods_DuplicateMethods()
{
    if (class_Methods_DuplicateMethods == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Methods_DuplicateMethods = mono_class_from_name(__managed_dll_image, "Methods", "DuplicateMethods");
    }
}

Methods_DuplicateMethods* Methods_DuplicateMethods_new()
{
    const char __method_name[] = "Methods.DuplicateMethods:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_DuplicateMethods();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_DuplicateMethods);
    }

    Methods_DuplicateMethods* object = (Methods_DuplicateMethods*) calloc(1, sizeof(Methods_DuplicateMethods));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Methods_DuplicateMethods);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Methods_DuplicateMethods_DoIt(Methods_DuplicateMethods* object)
{
    const char __method_name[] = "Methods.DuplicateMethods:DoIt()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_DuplicateMethods();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_DuplicateMethods);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Methods_DuplicateMethods_DoIt_1(Methods_DuplicateMethods* object, int32_t i)
{
    const char __method_name[] = "Methods.DuplicateMethods:DoIt(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_DuplicateMethods();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_DuplicateMethods);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &i;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Methods_DuplicateMethods_DoIt_2(Methods_DuplicateMethods* object, const char* s)
{
    const char __method_name[] = "Methods.DuplicateMethods:DoIt(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_DuplicateMethods();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_DuplicateMethods);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __s_0 = (s) ? mono_string_new(__mono_context.domain, s) : 0;
    __args[0] = __s_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Methods_DuplicateMethods_DoIt_3(Methods_DuplicateMethods* object, int32_t i, int32_t j)
{
    const char __method_name[] = "Methods.DuplicateMethods:DoIt(int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_DuplicateMethods();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_DuplicateMethods);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    __args[0] = &i;
    __args[1] = &j;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool Methods_DuplicateMethods_Find(Methods_DuplicateMethods* object, const char* name)
{
    const char __method_name[] = "Methods.DuplicateMethods:Find(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_DuplicateMethods();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_DuplicateMethods);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    MonoString* __name_0 = (name) ? mono_string_new(__mono_context.domain, name) : 0;
    __args[0] = __name_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

bool Methods_DuplicateMethods_Find_1(Methods_DuplicateMethods* object, const char* firstName, const char* lastName)
{
    const char __method_name[] = "Methods.DuplicateMethods:Find(string,string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_DuplicateMethods();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_DuplicateMethods);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[2];
    MonoString* __firstName_0 = (firstName) ? mono_string_new(__mono_context.domain, firstName) : 0;
    __args[0] = __firstName_0;
    MonoString* __lastName_1 = (lastName) ? mono_string_new(__mono_context.domain, lastName) : 0;
    __args[1] = __lastName_1;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Methods_SomeExtensions()
{
    if (class_Methods_SomeExtensions == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Methods_SomeExtensions = mono_class_from_name(__managed_dll_image, "Methods", "SomeExtensions");
    }
}

int32_t Methods_SomeExtensions_CountNonNull(Methods_Collection* collection)
{
    const char __method_name[] = "Methods.SomeExtensions:CountNonNull(Methods.Collection)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_SomeExtensions();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_SomeExtensions);
    }


    void* __args[1];
    __args[0] = collection ? mono_gchandle_get_target(collection->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Methods_SomeExtensions_CountNull(Methods_Collection* collection)
{
    const char __method_name[] = "Methods.SomeExtensions:CountNull(Methods.Collection)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_SomeExtensions();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_SomeExtensions);
    }


    void* __args[1];
    __args[0] = collection ? mono_gchandle_get_target(collection->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

bool Methods_SomeExtensions_IsEmptyButNotNull(const char* string)
{
    const char __method_name[] = "Methods.SomeExtensions:IsEmptyButNotNull(string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_SomeExtensions();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_SomeExtensions);
    }


    void* __args[1];
    MonoString* __string_0 = (string) ? mono_string_new(__mono_context.domain, string) : 0;
    __args[0] = __string_0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

int32_t Methods_SomeExtensions_Increment(int32_t value)
{
    const char __method_name[] = "Methods.SomeExtensions:Increment(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_SomeExtensions();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_SomeExtensions);
    }


    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

const char* Methods_SomeExtensions_NotAnExtensionMethod()
{
    const char __method_name[] = "Methods.SomeExtensions:NotAnExtensionMethod()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Methods_SomeExtensions();
        __method = mono_embeddinator_lookup_method(__method_name, class_Methods_SomeExtensions);
    }


    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_Comparable_Class()
{
    if (class_Comparable_Class == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Comparable_Class = mono_class_from_name(__managed_dll_image, "Comparable", "Class");
    }
}

Comparable_Class* Comparable_Class_new(int32_t i)
{
    const char __method_name[] = "Comparable.Class:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Class);
    }

    Comparable_Class* object = (Comparable_Class*) calloc(1, sizeof(Comparable_Class));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Comparable_Class);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &i;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Comparable_Class_get_Integer(Comparable_Class* object)
{
    const char __method_name[] = "Comparable.Class:get_Integer()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Comparable_Generic()
{
    if (class_Comparable_Generic == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Comparable_Generic = mono_class_from_name(__managed_dll_image, "Comparable", "Generic");
    }
}

Comparable_Generic* Comparable_Generic_new(int32_t i)
{
    const char __method_name[] = "Comparable.Generic:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Generic();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Generic);
    }

    Comparable_Generic* object = (Comparable_Generic*) calloc(1, sizeof(Comparable_Generic));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Comparable_Generic);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &i;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Comparable_Generic_get_Integer(Comparable_Generic* object)
{
    const char __method_name[] = "Comparable.Generic:get_Integer()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Generic();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Generic);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Comparable_Generic_CompareTo(Comparable_Generic* object, Comparable_Generic* other)
{
    const char __method_name[] = "Comparable.Generic:CompareTo(Comparable.Generic)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Generic();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Generic);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = other ? mono_gchandle_get_target(other->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Comparable_Both()
{
    if (class_Comparable_Both == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Comparable_Both = mono_class_from_name(__managed_dll_image, "Comparable", "Both");
    }
}

Comparable_Both* Comparable_Both_new(int32_t i)
{
    const char __method_name[] = "Comparable.Both:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Both();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Both);
    }

    Comparable_Both* object = (Comparable_Both*) calloc(1, sizeof(Comparable_Both));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Comparable_Both);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &i;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Comparable_Both_get_Integer(Comparable_Both* object)
{
    const char __method_name[] = "Comparable.Both:get_Integer()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Both();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Both);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Comparable_Both_CompareTo(Comparable_Both* object, Comparable_Both* other)
{
    const char __method_name[] = "Comparable.Both:CompareTo(Comparable.Both)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Both();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Both);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = other ? mono_gchandle_get_target(other->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Comparable_Different()
{
    if (class_Comparable_Different == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Comparable_Different = mono_class_from_name(__managed_dll_image, "Comparable", "Different");
    }
}

Comparable_Different* Comparable_Different_new(int32_t i)
{
    const char __method_name[] = "Comparable.Different:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Different();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Different);
    }

    Comparable_Different* object = (Comparable_Different*) calloc(1, sizeof(Comparable_Different));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Comparable_Different);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &i;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Comparable_Different_get_Integer(Comparable_Different* object)
{
    const char __method_name[] = "Comparable.Different:get_Integer()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Different();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Different);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Comparable_Different_CompareTo(Comparable_Different* object, Comparable_Generic* generic)
{
    const char __method_name[] = "Comparable.Different:CompareTo(Comparable.Generic)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Different();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Different);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = generic ? mono_gchandle_get_target(generic->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

int32_t Comparable_Different_CompareTo_1(Comparable_Different* object, int32_t integer)
{
    const char __method_name[] = "Comparable.Different:CompareTo(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Comparable_Different();
        __method = mono_embeddinator_lookup_method(__method_name, class_Comparable_Different);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &integer;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Fields_Class()
{
    if (class_Fields_Class == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Fields_Class = mono_class_from_name(__managed_dll_image, "Fields", "Class");
    }
}

Fields_Class* Fields_Class_new(bool enabled)
{
    const char __method_name[] = "Fields.Class:.ctor(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Fields_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_Fields_Class);
    }

    Fields_Class* object = (Fields_Class*) calloc(1, sizeof(Fields_Class));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Fields_Class);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &enabled;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int64_t Fields_Class_get_MaxLong()
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "MaxLong";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, 0);
    void* __unbox = mono_object_unbox(__result);
    return *((int64_t*)__unbox);
}

void Fields_Class_set_MaxLong(int64_t value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "MaxLong";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    void* __value = &value;
    MonoVTable* __vtable = mono_class_vtable(__mono_context.domain, class_Fields_Class);
    mono_field_static_set_value(__vtable, __field, __value);
}

Fields_Class* Fields_Class_get_Scratch()
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Scratch";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, 0);
    Fields_Class* __result_obj = __result ? (Fields_Class*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void Fields_Class_set_Scratch(Fields_Class* value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Scratch";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    void* __value = value ? mono_gchandle_get_target(value->_handle) : 0;
    MonoVTable* __vtable = mono_class_vtable(__mono_context.domain, class_Fields_Class);
    mono_field_static_set_value(__vtable, __field, __value);
}

int32_t Fields_Class_get_Integer()
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Integer";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, 0);
    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void Fields_Class_set_Integer(int32_t value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Integer";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    void* __value = &value;
    MonoVTable* __vtable = mono_class_vtable(__mono_context.domain, class_Fields_Class);
    mono_field_static_set_value(__vtable, __field, __value);
}

bool Fields_Class_get_Boolean(Fields_Class* object)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Boolean";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, __instance);
    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

void Fields_Class_set_Boolean(Fields_Class* object, bool value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Boolean";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    void* __value = &value;
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    mono_field_set_value(__instance, __field, __value);
}

Fields_Struct* Fields_Class_get_Structure(Fields_Class* object)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Structure";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, __instance);
    Fields_Struct* __result_obj = __result ? (Fields_Struct*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void Fields_Class_set_Structure(Fields_Class* object, Fields_Struct* value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Class();
        const char __field_name[] = "Structure";
        __field = mono_class_get_field_from_name(class_Fields_Class, __field_name);
    }
    void* __value = mono_object_unbox(value ? mono_gchandle_get_target(value->_handle) : 0);
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    mono_field_set_value(__instance, __field, __value);
}

static void __lookup_class_Fields_Struct()
{
    if (class_Fields_Struct == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Fields_Struct = mono_class_from_name(__managed_dll_image, "Fields", "Struct");
    }
}

Fields_Struct* Fields_Struct_new(bool enabled)
{
    const char __method_name[] = "Fields.Struct:.ctor(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Fields_Struct();
        __method = mono_embeddinator_lookup_method(__method_name, class_Fields_Struct);
    }

    Fields_Struct* object = (Fields_Struct*) calloc(1, sizeof(Fields_Struct));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Fields_Struct);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &enabled;
    MonoObject* __exception = 0;
    MonoObject* __result;
    void* __unboxed = mono_object_unbox(__instance);
    __result = mono_runtime_invoke(__method, __unboxed, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Fields_Struct* Fields_Struct_get_Empty()
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Empty";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, 0);
    Fields_Struct* __result_obj = __result ? (Fields_Struct*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void Fields_Struct_set_Empty(Fields_Struct* value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Empty";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    void* __value = mono_object_unbox(value ? mono_gchandle_get_target(value->_handle) : 0);
    MonoVTable* __vtable = mono_class_vtable(__mono_context.domain, class_Fields_Struct);
    mono_field_static_set_value(__vtable, __field, __value);
}

Fields_Struct* Fields_Struct_get_Scratch()
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Scratch";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, 0);
    Fields_Struct* __result_obj = __result ? (Fields_Struct*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void Fields_Struct_set_Scratch(Fields_Struct* value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Scratch";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    void* __value = mono_object_unbox(value ? mono_gchandle_get_target(value->_handle) : 0);
    MonoVTable* __vtable = mono_class_vtable(__mono_context.domain, class_Fields_Struct);
    mono_field_static_set_value(__vtable, __field, __value);
}

int32_t Fields_Struct_get_Integer()
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Integer";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, 0);
    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void Fields_Struct_set_Integer(int32_t value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Integer";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    void* __value = &value;
    MonoVTable* __vtable = mono_class_vtable(__mono_context.domain, class_Fields_Struct);
    mono_field_static_set_value(__vtable, __field, __value);
}

bool Fields_Struct_get_Boolean(Fields_Struct* object)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Boolean";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, __instance);
    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

void Fields_Struct_set_Boolean(Fields_Struct* object, bool value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Boolean";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    void* __value = &value;
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    mono_field_set_value(__instance, __field, __value);
}

Fields_Class* Fields_Struct_get_Class(Fields_Struct* object)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Class";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    MonoObject* __result = mono_field_get_value_object(__mono_context.domain, __field, __instance);
    Fields_Class* __result_obj = __result ? (Fields_Class*) mono_embeddinator_create_object(__result) : 0;
    return __result_obj;
}

void Fields_Struct_set_Class(Fields_Struct* object, Fields_Class* value)
{
    static MonoClassField *__field = 0;
    if (!__field)
    {
        __lookup_class_Fields_Struct();
        const char __field_name[] = "Class";
        __field = mono_class_get_field_from_name(class_Fields_Struct, __field_name);
    }
    void* __value = value ? mono_gchandle_get_target(value->_handle) : 0;
    MonoObject* __instance = mono_gchandle_get_target(object->_handle);
    mono_field_set_value(__instance, __field, __value);
}

static void __lookup_class_Exceptions_Throwers()
{
    if (class_Exceptions_Throwers == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Exceptions_Throwers = mono_class_from_name(__managed_dll_image, "Exceptions", "Throwers");
    }
}

Exceptions_Throwers* Exceptions_Throwers_new()
{
    const char __method_name[] = "Exceptions.Throwers:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Exceptions_Throwers();
        __method = mono_embeddinator_lookup_method(__method_name, class_Exceptions_Throwers);
    }

    Exceptions_Throwers* object = (Exceptions_Throwers*) calloc(1, sizeof(Exceptions_Throwers));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Exceptions_Throwers);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_Exceptions_ThrowInStaticCtor()
{
    if (class_Exceptions_ThrowInStaticCtor == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Exceptions_ThrowInStaticCtor = mono_class_from_name(__managed_dll_image, "Exceptions", "ThrowInStaticCtor");
    }
}

Exceptions_ThrowInStaticCtor* Exceptions_ThrowInStaticCtor_new()
{
    const char __method_name[] = "Exceptions.ThrowInStaticCtor:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Exceptions_ThrowInStaticCtor();
        __method = mono_embeddinator_lookup_method(__method_name, class_Exceptions_ThrowInStaticCtor);
    }

    Exceptions_ThrowInStaticCtor* object = (Exceptions_ThrowInStaticCtor*) calloc(1, sizeof(Exceptions_ThrowInStaticCtor));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Exceptions_ThrowInStaticCtor);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_Exceptions_Base()
{
    if (class_Exceptions_Base == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Exceptions_Base = mono_class_from_name(__managed_dll_image, "Exceptions", "Base");
    }
}

Exceptions_Base* Exceptions_Base_new(bool broken)
{
    const char __method_name[] = "Exceptions.Base:.ctor(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Exceptions_Base();
        __method = mono_embeddinator_lookup_method(__method_name, class_Exceptions_Base);
    }

    Exceptions_Base* object = (Exceptions_Base*) calloc(1, sizeof(Exceptions_Base));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Exceptions_Base);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &broken;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_Exceptions_Super()
{
    if (class_Exceptions_Super == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Exceptions_Super = mono_class_from_name(__managed_dll_image, "Exceptions", "Super");
    }
}

Exceptions_Super* Exceptions_Super_new(bool broken)
{
    const char __method_name[] = "Exceptions.Super:.ctor(bool)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Exceptions_Super();
        __method = mono_embeddinator_lookup_method(__method_name, class_Exceptions_Super);
    }

    Exceptions_Super* object = (Exceptions_Super*) calloc(1, sizeof(Exceptions_Super));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Exceptions_Super);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &broken;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_EqualsHashOverrides_Class()
{
    if (class_EqualsHashOverrides_Class == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_EqualsHashOverrides_Class = mono_class_from_name(__managed_dll_image, "EqualsHashOverrides", "Class");
    }
}

EqualsHashOverrides_Class* EqualsHashOverrides_Class_new(int32_t x)
{
    const char __method_name[] = "EqualsHashOverrides.Class:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_Class);
    }

    EqualsHashOverrides_Class* object = (EqualsHashOverrides_Class*) calloc(1, sizeof(EqualsHashOverrides_Class));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_EqualsHashOverrides_Class);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &x;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t EqualsHashOverrides_Class_get_X(EqualsHashOverrides_Class* object)
{
    const char __method_name[] = "EqualsHashOverrides.Class:get_X()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void EqualsHashOverrides_Class_set_X(EqualsHashOverrides_Class* object, int32_t value)
{
    const char __method_name[] = "EqualsHashOverrides.Class:set_X(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_Class();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_Class);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

static void __lookup_class_EqualsHashOverrides_EquatableClass()
{
    if (class_EqualsHashOverrides_EquatableClass == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_EqualsHashOverrides_EquatableClass = mono_class_from_name(__managed_dll_image, "EqualsHashOverrides", "EquatableClass");
    }
}

EqualsHashOverrides_EquatableClass* EqualsHashOverrides_EquatableClass_new(int32_t y)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableClass:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableClass);
    }

    EqualsHashOverrides_EquatableClass* object = (EqualsHashOverrides_EquatableClass*) calloc(1, sizeof(EqualsHashOverrides_EquatableClass));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_EqualsHashOverrides_EquatableClass);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &y;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t EqualsHashOverrides_EquatableClass_get_Y(EqualsHashOverrides_EquatableClass* object)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableClass:get_Y()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void EqualsHashOverrides_EquatableClass_set_Y(EqualsHashOverrides_EquatableClass* object, int32_t value)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableClass:set_Y(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

bool EqualsHashOverrides_EquatableClass_Equals(EqualsHashOverrides_EquatableClass* object, EqualsHashOverrides_Class* obj)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableClass:Equals(EqualsHashOverrides.Class)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableClass();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableClass);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = obj ? mono_gchandle_get_target(obj->_handle) : 0;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_EqualsHashOverrides_EquatableInt()
{
    if (class_EqualsHashOverrides_EquatableInt == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_EqualsHashOverrides_EquatableInt = mono_class_from_name(__managed_dll_image, "EqualsHashOverrides", "EquatableInt");
    }
}

EqualsHashOverrides_EquatableInt* EqualsHashOverrides_EquatableInt_new(int32_t y)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableInt:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableInt();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableInt);
    }

    EqualsHashOverrides_EquatableInt* object = (EqualsHashOverrides_EquatableInt*) calloc(1, sizeof(EqualsHashOverrides_EquatableInt));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_EqualsHashOverrides_EquatableInt);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &y;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t EqualsHashOverrides_EquatableInt_get_Y(EqualsHashOverrides_EquatableInt* object)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableInt:get_Y()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableInt();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableInt);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

void EqualsHashOverrides_EquatableInt_set_Y(EqualsHashOverrides_EquatableInt* object, int32_t value)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableInt:set_Y(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableInt();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableInt);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &value;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

}

bool EqualsHashOverrides_EquatableInt_Equals(EqualsHashOverrides_EquatableInt* object, int32_t obj)
{
    const char __method_name[] = "EqualsHashOverrides.EquatableInt:Equals(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_EqualsHashOverrides_EquatableInt();
        __method = mono_embeddinator_lookup_method(__method_name, class_EqualsHashOverrides_EquatableInt);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    void* __args[1];
    __args[0] = &obj;
    MonoObject* __exception = 0;
    MonoObject* __result;
    MonoMethod* __virtual_method = mono_object_get_virtual_method(__instance, __method);
    __result = mono_runtime_invoke(__virtual_method, __instance, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Enums_Enumer()
{
    if (class_Enums_Enumer == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Enums_Enumer = mono_class_from_name(__managed_dll_image, "Enums", "Enumer");
    }
}

Enums_ByteFlags Enums_Enumer_Test(Enums_ByteEnum b, Enums_IntEnum* i, Enums_ShortEnum* s)
{
    const char __method_name[] = "Enums.Enumer:Test(Enums.ByteEnum,Enums.IntEnum&,Enums.ShortEnum&)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Enums_Enumer();
        __method = mono_embeddinator_lookup_method(__method_name, class_Enums_Enumer);
    }


    void* __args[3];
    __args[0] = &b;
    __args[1] = i;
    short __s = *((short*) s);
    __args[2] = &__s;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, 0, __args, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }
    *s = (Enums_ShortEnum) __s;

    void* __unbox = mono_object_unbox(__result);
    return *((Enums_ByteFlags*)__unbox);
}

static void __lookup_class_Constructors_Unique()
{
    if (class_Constructors_Unique == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Constructors_Unique = mono_class_from_name(__managed_dll_image, "Constructors", "Unique");
    }
}

Constructors_Unique* Constructors_Unique_new()
{
    const char __method_name[] = "Constructors.Unique:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Unique();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Unique);
    }

    Constructors_Unique* object = (Constructors_Unique*) calloc(1, sizeof(Constructors_Unique));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_Unique);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Constructors_Unique* Constructors_Unique_new_1(int32_t id)
{
    const char __method_name[] = "Constructors.Unique:.ctor(int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Unique();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Unique);
    }

    Constructors_Unique* object = (Constructors_Unique*) calloc(1, sizeof(Constructors_Unique));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_Unique);
    mono_embeddinator_init_object(object, __instance);

    void* __args[1];
    __args[0] = &id;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

int32_t Constructors_Unique_get_Id(Constructors_Unique* object)
{
    const char __method_name[] = "Constructors.Unique:get_Id()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Unique();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Unique);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((int32_t*)__unbox);
}

static void __lookup_class_Constructors_SuperUnique()
{
    if (class_Constructors_SuperUnique == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Constructors_SuperUnique = mono_class_from_name(__managed_dll_image, "Constructors", "SuperUnique");
    }
}

Constructors_SuperUnique* Constructors_SuperUnique_new()
{
    const char __method_name[] = "Constructors.SuperUnique:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_SuperUnique();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_SuperUnique);
    }

    Constructors_SuperUnique* object = (Constructors_SuperUnique*) calloc(1, sizeof(Constructors_SuperUnique));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_SuperUnique);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

static void __lookup_class_Constructors_Implicit()
{
    if (class_Constructors_Implicit == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Constructors_Implicit = mono_class_from_name(__managed_dll_image, "Constructors", "Implicit");
    }
}

Constructors_Implicit* Constructors_Implicit_new()
{
    const char __method_name[] = "Constructors.Implicit:.ctor()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Implicit();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Implicit);
    }

    Constructors_Implicit* object = (Constructors_Implicit*) calloc(1, sizeof(Constructors_Implicit));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_Implicit);
    mono_embeddinator_init_object(object, __instance);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

const char* Constructors_Implicit_get_TestResult(Constructors_Implicit* object)
{
    const char __method_name[] = "Constructors.Implicit:get_TestResult()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Implicit();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Implicit);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    char* __string = mono_string_to_utf8((MonoString*) __result);
    return __string;
}

static void __lookup_class_Constructors_AllTypeCode()
{
    if (class_Constructors_AllTypeCode == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Constructors_AllTypeCode = mono_class_from_name(__managed_dll_image, "Constructors", "AllTypeCode");
    }
}

Constructors_AllTypeCode* Constructors_AllTypeCode_new(bool b1, gunichar2 c2, const char* s)
{
    const char __method_name[] = "Constructors.AllTypeCode:.ctor(bool,char,string)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_AllTypeCode();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_AllTypeCode);
    }

    Constructors_AllTypeCode* object = (Constructors_AllTypeCode*) calloc(1, sizeof(Constructors_AllTypeCode));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_AllTypeCode);
    mono_embeddinator_init_object(object, __instance);

    void* __args[3];
    __args[0] = &b1;
    __args[1] = &c2;
    MonoString* __s_2 = (s) ? mono_string_new(__mono_context.domain, s) : 0;
    __args[2] = __s_2;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Constructors_AllTypeCode* Constructors_AllTypeCode_new_1(int8_t i8, int16_t i16, int32_t i32, int64_t i64)
{
    const char __method_name[] = "Constructors.AllTypeCode:.ctor(sbyte,int16,int,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_AllTypeCode();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_AllTypeCode);
    }

    Constructors_AllTypeCode* object = (Constructors_AllTypeCode*) calloc(1, sizeof(Constructors_AllTypeCode));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_AllTypeCode);
    mono_embeddinator_init_object(object, __instance);

    void* __args[4];
    __args[0] = &i8;
    __args[1] = &i16;
    __args[2] = &i32;
    __args[3] = &i64;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Constructors_AllTypeCode* Constructors_AllTypeCode_new_2(uint8_t u8, uint16_t u16, uint32_t u32, uint64_t u64)
{
    const char __method_name[] = "Constructors.AllTypeCode:.ctor(byte,uint16,uint,ulong)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_AllTypeCode();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_AllTypeCode);
    }

    Constructors_AllTypeCode* object = (Constructors_AllTypeCode*) calloc(1, sizeof(Constructors_AllTypeCode));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_AllTypeCode);
    mono_embeddinator_init_object(object, __instance);

    void* __args[4];
    __args[0] = &u8;
    __args[1] = &u16;
    __args[2] = &u32;
    __args[3] = &u64;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Constructors_AllTypeCode* Constructors_AllTypeCode_new_3(float f32, double f64)
{
    const char __method_name[] = "Constructors.AllTypeCode:.ctor(single,double)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_AllTypeCode();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_AllTypeCode);
    }

    Constructors_AllTypeCode* object = (Constructors_AllTypeCode*) calloc(1, sizeof(Constructors_AllTypeCode));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_AllTypeCode);
    mono_embeddinator_init_object(object, __instance);

    void* __args[2];
    __args[0] = &f32;
    __args[1] = &f64;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

bool Constructors_AllTypeCode_get_TestResult(Constructors_AllTypeCode* object)
{
    const char __method_name[] = "Constructors.AllTypeCode:get_TestResult()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_AllTypeCode();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_AllTypeCode);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Constructors_DefaultValues()
{
    if (class_Constructors_DefaultValues == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Constructors_DefaultValues = mono_class_from_name(__managed_dll_image, "Constructors", "DefaultValues");
    }
}

Constructors_DefaultValues* Constructors_DefaultValues_new(uint8_t b, int16_t s, int32_t i, int64_t l)
{
    const char __method_name[] = "Constructors.DefaultValues:.ctor(byte,int16,int,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_DefaultValues();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_DefaultValues);
    }

    Constructors_DefaultValues* object = (Constructors_DefaultValues*) calloc(1, sizeof(Constructors_DefaultValues));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_DefaultValues);
    mono_embeddinator_init_object(object, __instance);

    void* __args[4];
    __args[0] = &b;
    __args[1] = &s;
    __args[2] = &i;
    __args[3] = &l;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Constructors_DefaultValues* Constructors_DefaultValues_new_1(int32_t nonDefault, const char* s, float f, double d, Enums_ByteEnum e)
{
    const char __method_name[] = "Constructors.DefaultValues:.ctor(int,string,single,double,Enums.ByteEnum)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_DefaultValues();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_DefaultValues);
    }

    Constructors_DefaultValues* object = (Constructors_DefaultValues*) calloc(1, sizeof(Constructors_DefaultValues));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_DefaultValues);
    mono_embeddinator_init_object(object, __instance);

    void* __args[5];
    __args[0] = &nonDefault;
    MonoString* __s_1 = (s) ? mono_string_new(__mono_context.domain, s) : 0;
    __args[1] = __s_1;
    __args[2] = &f;
    __args[3] = &d;
    __args[4] = &e;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

bool Constructors_DefaultValues_get_IsDefault(Constructors_DefaultValues* object)
{
    const char __method_name[] = "Constructors.DefaultValues:get_IsDefault()";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_DefaultValues();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_DefaultValues);
    }

    MonoObject* __instance = mono_gchandle_get_target(object->_handle);

    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, 0, &__exception);

    if (__exception)
    {
        mono_embeddinator_throw_exception(__exception);
    }

    void* __unbox = mono_object_unbox(__result);
    return *((bool*)__unbox);
}

static void __lookup_class_Constructors_Duplicates()
{
    if (class_Constructors_Duplicates == 0)
    {
        __initialize_mono();
        __lookup_assembly_managed_dll();
        class_Constructors_Duplicates = mono_class_from_name(__managed_dll_image, "Constructors", "Duplicates");
    }
}

Constructors_Duplicates* Constructors_Duplicates_new(uint8_t b, int16_t s, int32_t i, int64_t l)
{
    const char __method_name[] = "Constructors.Duplicates:.ctor(byte,int16,int,long)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Duplicates();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Duplicates);
    }

    Constructors_Duplicates* object = (Constructors_Duplicates*) calloc(1, sizeof(Constructors_Duplicates));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_Duplicates);
    mono_embeddinator_init_object(object, __instance);

    void* __args[4];
    __args[0] = &b;
    __args[1] = &s;
    __args[2] = &i;
    __args[3] = &l;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Constructors_Duplicates* Constructors_Duplicates_new_1(int32_t b, int32_t s, int32_t i, int32_t l)
{
    const char __method_name[] = "Constructors.Duplicates:.ctor(int,int,int,int)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Duplicates();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Duplicates);
    }

    Constructors_Duplicates* object = (Constructors_Duplicates*) calloc(1, sizeof(Constructors_Duplicates));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_Duplicates);
    mono_embeddinator_init_object(object, __instance);

    void* __args[4];
    __args[0] = &b;
    __args[1] = &s;
    __args[2] = &i;
    __args[3] = &l;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}

Constructors_Duplicates* Constructors_Duplicates_new_2(uint8_t b, uint8_t s, uint8_t i, uint8_t l)
{
    const char __method_name[] = "Constructors.Duplicates:.ctor(byte,byte,byte,byte)";
    static MonoMethod *__method = 0;

    if (!__method)
    {
        __lookup_class_Constructors_Duplicates();
        __method = mono_embeddinator_lookup_method(__method_name, class_Constructors_Duplicates);
    }

    Constructors_Duplicates* object = (Constructors_Duplicates*) calloc(1, sizeof(Constructors_Duplicates));
    MonoObject* __instance = mono_object_new(__mono_context.domain, class_Constructors_Duplicates);
    mono_embeddinator_init_object(object, __instance);

    void* __args[4];
    __args[0] = &b;
    __args[1] = &s;
    __args[2] = &i;
    __args[3] = &l;
    MonoObject* __exception = 0;
    MonoObject* __result;
    __result = mono_runtime_invoke(__method, __instance, __args, &__exception);

    if (__exception)
    {
        free(object);
        mono_embeddinator_throw_exception(__exception);
        return 0;
    }

    return object;
}
